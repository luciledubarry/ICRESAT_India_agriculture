---
title: "Fichier 2 : Nettoyer la base Cultivation 2014"
format: html
editor: source
---

```{r, message=FALSE, warning=FALSE}
rm(list = ls())
graphics.off()
cat("\014")
```

```{r}
#| message: false
here::i_am("ICRESAT_database_analysis/CultData2_cleaning.qmd")
library(dplyr)
library(tidyr)
library(knitr)
library(readxl)
library(ggplot2)
library(scales)
library(stringr)    
library(gt)
```


```{r}
Cultivation_2014 <- readRDS(here::here("Base de données générées", "Cultivation_2014", "Cultivation_2014.rds"))
```

```{r}
Cultivation_2014 <- Cultivation_2014 |>
  mutate(SEASON = toupper(SEASON))
```

## Premières analyses

### Principales cultures

```{r}
# Tableau des principales cultures
main_crops <- Cultivation_2014 |>
  select(
    VDS_ID, PLOT_CODE, SEASON,
    starts_with("CROP_")
  ) |>
  distinct() |>
  pivot_longer(
    cols = c(CROP_1, CROP_2, CROP_3, CROP_4),
    names_to = "CROP_POSITION",
    values_to = "CROP"
  ) |>
  filter(!is.na(CROP) & CROP != "") |>
  count(CROP, name = "nb_occurrences") |>
  arrange(desc(nb_occurrences)) |>
  inner_join(
    Cultivation_2014 |>
      select(CROP = CROP_1, CROP_ID = CROP_1_ID), by = "CROP"
  ) |>
  distinct()
```

### Salaire horaire

```{r}
Cultivation_2014 |>
  filter(LAB_TYPE != "6", LAB_TYPE != "B", LAB_TYPE != "EB", LAB_TYPE != "HB", LAB_TYPE != "OB", LAB_TYPE != "FB") |>
  filter(WAGE_PER_HR < 400) |>
  ggplot(aes(x = LAB_TYPE, y = WAGE_PER_HR)) +
  geom_boxplot(fill = "palegreen") +
  theme_minimal() +
  labs(
    x = "",
    y = "Salaire en roupies",
    title = "Distribution du salaire horaire par type de main d'oeuvre"
  )
# Le filtre exclut 3 valeurs invraisemblables, au-dessous de 1000 roupies par heure. 
```


```{r}
Cultivation_2014 |>
  filter(LAB_TYPE != "6", LAB_TYPE != "B", LAB_TYPE != "RS") |>
  filter(WAGE_PER_HR < 400) |>
  mutate(Sous_Categorie = case_when(
    substr(LAB_TYPE, 2, 2) == "M" ~ "Men",
    substr(LAB_TYPE, 2, 2) == "F" ~ "Women",
    substr(LAB_TYPE, 2, 2) == "C" ~ "Children",
    substr(LAB_TYPE, 2, 2) == "B" ~ "Bullocks",
    TRUE ~ "Autre"
  )) |>
  group_by(Sous_Categorie) |>
  ggplot(aes(x = Sous_Categorie, y = WAGE_PER_HR)) +
  geom_boxplot(fill = "lightpink") +
  theme_minimal() +
  labs(
    x = "",
    y = "Salaire en roupies",
    title = "Distribution du salaire horaire par type de main d'oeuvre (regroupé)")
```

```{r}
Cultivation_2014 |>
  filter(LAB_TYPE != "6", LAB_TYPE != "B") |>
  group_by(LAB_TYPE) |>
  summarize(mean_wage_per_hr = mean(WAGE_PER_HR, na.rm = TRUE)) |>
  ggplot(aes(x = LAB_TYPE, y = mean_wage_per_hr)) +
  geom_col(fill = "lightskyblue") +
  theme_minimal() +
  labs(
    x = "",
    y = "Salaire en roupies",
    title = "Moyenne du salaire horaire par type de main d'oeuvre")
```

```{r}
# Filter pour le travail employé (hired)
Cultivation_2014 |>
  filter(LAB_TYPE %in% c("HF", "HM", "HC", "HB")) |>
  mutate(Sous_Categorie = case_when(
    substr(LAB_TYPE, 2, 2) == "M" ~ "Men",
    substr(LAB_TYPE, 2, 2) == "F" ~ "Women",
    substr(LAB_TYPE, 2, 2) == "C" ~ "Children",
    substr(LAB_TYPE, 2, 2) == "B" ~ "Bullocks",
    TRUE ~ "Autre"
  )) |>
  group_by(Sous_Categorie) |>
  summarize(mean_wage_per_hr = mean(WAGE_PER_HR, na.rm = TRUE)) |>
  ggplot(aes(x = Sous_Categorie, y = mean_wage_per_hr)) +
  geom_col(fill = "lightslateblue") +
  theme_minimal() +
  labs(
    x = "",
    y = "Salaire en roupies",
    title = "Moyenne du salaire horaire des travailleurs employés")
```

```{r}
tableau_valeurs <- Cultivation_2014 |>
  summarize(
    Supérieur_50 = sum(WAGE_PER_HR > 50, na.rm = TRUE),
    Supérieur_100 = sum(WAGE_PER_HR > 100, na.rm = TRUE),
    Supérieur_1000 = sum(WAGE_PER_HR > 1000, na.rm = TRUE)
  )

tableau_valeurs
```

## Pivoter Cultivation : mettre les CROP en ligne

```{r}
# Diviser PLOT_AREA pour chaque culture, selon les variables PRCT_AREA
Cultivation_cult_distinctes <- Cultivation_2014 |>
  mutate(
    AREA_CROP_1 = PLOT_AREA * PRCT_AREA_1 / 100,
    AREA_CROP_2 = if_else(!is.na(PRCT_AREA_2), PLOT_AREA * PRCT_AREA_2 / 100, NA_real_),
    AREA_CROP_3 = if_else(!is.na(PRCT_AREA_3), PLOT_AREA * PRCT_AREA_3 / 100, NA_real_),
    AREA_CROP_4 = if_else(!is.na(PRCT_AREA_4), PLOT_AREA * PRCT_AREA_4 / 100, NA_real_)
  )

# Diviser IRRI_AREA pour chaque culture, selon les variables PRCT_AREA
Cultivation_cult_distinctes <- Cultivation_cult_distinctes |>
  mutate(
    IRRI_CROP_1 = IRRI_AREA * PRCT_AREA_1 / 100,
    IRRI_CROP_2 = if_else(!is.na(PRCT_AREA_2), IRRI_AREA * PRCT_AREA_2 / 100, NA_real_),
    IRRI_CROP_3 = if_else(!is.na(PRCT_AREA_3), IRRI_AREA * PRCT_AREA_3 / 100, NA_real_),
    IRRI_CROP_4 = if_else(!is.na(PRCT_AREA_4), IRRI_AREA * PRCT_AREA_4 / 100, NA_real_)
  )
```

```{r Calculer le nombre d'heures de travail et la variable heure par hectare selon la proportion de chaque culture}
# Recalculer la variable WORK_HR selon les variables PRCT_CROP
Cultivation_cult_distinctes <- Cultivation_cult_distinctes |>
  mutate(
WORK_HR_1 = if_else(PRCT_AREA_1 == 0, NA_real_, WORK_HR * PRCT_AREA_1 / 100),
WORK_HR_2 = if_else(PRCT_AREA_2 == 0, NA_real_, WORK_HR * PRCT_AREA_2 / 100),
WORK_HR_3 = if_else(PRCT_AREA_3 == 0, NA_real_, WORK_HR * PRCT_AREA_3 / 100),
WORK_HR_4 = if_else(PRCT_AREA_4 == 0, NA_real_, WORK_HR * PRCT_AREA_4 / 100),
  )
```

```{r}
Cultivation_cult_distinctes <- Cultivation_cult_distinctes |>
  select(-WORK_HR, -WAGE_PER_HR, -WAGE, -IRRI_AREA, -PLOT_AREA, -OPER_ID)

Cultivation_cult_distinctes <- Cultivation_cult_distinctes |>
  rename(CROP_ID_1 = CROP_1_ID) |>
  rename(CROP_ID_2 = CROP_2_ID) |>
  rename(CROP_ID_3 = CROP_3_ID) |>
  rename(CROP_ID_4 = CROP_4_ID)
```

```{r}
# Pivoter Cultivation en lignes pour les variables CROP, CROP_ID, PRCT_AREA, VAR_NAME, VAR_TYPE, AREA_CROP, HR_WORK, HR_PER_ACRE
Cultivation_cult_distinctes <- Cultivation_cult_distinctes |>
  pivot_longer(
    cols = matches("^(CROP|CROP_ID|PRCT_AREA|VAR_NAME|VAR_TYPE|AREA_CROP|IRRI_CROP|WORK_HR)_[1-4]$"),
    names_to = c(".value", "NB"),
    names_pattern = "(.*)_(\\d)"
  )
```

```{r}
# Supprimer les lignes qui n'ont pas de crop, soit PRCT_AREA == 0
Cultivation_cult_distinctes <- Cultivation_cult_distinctes |>
  filter(!PRCT_AREA == 0) |>
  select(-NB, -PRCT_AREA) |>
  relocate(AREA_CROP, .after = PLOT_CODE) |>
  relocate(IRRI_CROP, .after = AREA_CROP) |>
  relocate(VAR_TYPE, .before = VAR_NAME)
```


## Nouvelles variables

### Recatégoriser Opération

```{r}
# Nouvelles catégories OPERATION
cat_operations <- tribble(
  ~OLD_OPERATION,        ~OPERATION,

  "HAND WEEDING",        "HAND WEEDING",
  "HARVESTING",          "HARVESTING & THRESHING",
  "THRESHING",           "HARVESTING & THRESHING",
  "HARVESTING/THRESHING","HARVESTING & THRESHING",
  "WINNOWING",           "HARVESTING & THRESHING",
  "INTERCULTURE",        "INTERCULTURE",
  "THINNING",            "INTERCULTURE",
  "PINCHING/CUTTING",    "INTERCULTURE",
  "MULCHING",            "INTERCULTURE",
  "FENCE TRIMMING",      "INTERCULTURE",
  "GIRDLING",            "INTERCULTURE",
  "IRRIGATION",          "IRRIGATION",
  "LAND PREPARATION",    "LAND PREPARATION",
  "BUNDING",             "LAND PREPARATION",
  "DIGGING",             "LAND PREPARATION",
  "LEVELING",            "LAND PREPARATION",
  "FIELD CLEANING",      "LAND PREPARATION",
  "MARKETING",           "MARKETING",
  "ABELING",             "MARKETING",
  "BY PRODUCT MAKING",   "MARKETING",
  "TRANSFORMATION",      "MARKETING",
  "GRADING/TAGGING",     "MARKETING",
  "SOWING",              "SEED SOWING",
  "DIPPING",             "SEED SOWING",
  "TRANSPLANTING",       "TRANSPLANTING",
  "UPROOTING",           "TRANSPLANTING",
  "PLANT PROTECTION",    "PLANT PROTECTION MEASURES",
  "PESTICIDE",           "PLANT PROTECTION MEASURES",
  "HERBICIDE",           "PLANT PROTECTION MEASURES",
  "FUMIGATION",          "PLANT PROTECTION MEASURES",
  "FERTILIZER",          "CHEMICAL FERTILIZER APPL.",
  "SUPERVISION",         "SUPERVISION",
  "TRANSPORT",           "TRANSPORT",
  "LOADING",             "TRANSPORT",
  "NURSERY RAISING",     "NURSERY RAISING",
  "POD COLLECTION",      "OTHERS",
  "CURING",              "OTHERS",
  "TRANSFORMATION",      "OTHERS",
  "BY PRODUCT MAKING",   "OTHERS"
)
```

```{r, warning=FALSE}
# Ajouter les nouvelles catégories d'OPERATION dans Cultivation_cult_distinctes
Cultivation_cult_distinctes <- Cultivation_cult_distinctes |>
  rename(OLD_OPERATION = OPERATION) |>
  left_join(cat_operations, by = "OLD_OPERATION") |>
  relocate(OPERATION, .after = DT_OPER) |>
  select(-OLD_OPERATION)
```

### Variable Month

```{r}
Cultivation_cult_distinctes <- Cultivation_cult_distinctes |>
  mutate(MONTH = substr(SUR_MON_YR, 1, 2)) |>
  mutate(
    MONTH = recode(MONTH,
                      `01` = "janv",
                      `02` = "feb",
                      `03` = "march",
                      `04` = "april",
                      `05` = "may",
                      `06` = "june",
                      `07` = "july",
                      `08` = "aug",
                      `09` = "sept",
                      `10` = "oct",
                      `11` = "nov",
                      `12` = "dec")
  )
```

### Variable Gender

J'intégre le travail fait par les bullocks dans le travail des hommes, puisque cela inclut le conducteur. 

```{r}
# Créer la variable GENDER à partir de LAB_TYPE
Cultivation_cult_distinctes <- Cultivation_cult_distinctes |>
  mutate(
    GENDER = case_when(
      LAB_TYPE %in% c("HF", "FF", "EF") ~ "Female",
      LAB_TYPE %in% c("HM", "FM", "EM", "OB", "HB", "EB") ~ "Male",
      LAB_TYPE %in% c("HC", "FC", "EC") ~ "Child",
      TRUE ~ "Other"
    )
  )
```

### Variable Employment

```{r}
# Créer la variable EMPLOYMENT à partir de LAB_TYPE
Cultivation_cult_distinctes <- Cultivation_cult_distinctes |>
  mutate(
    EMPLOYMENT = case_when(
      LAB_TYPE %in% c("HF", "HM", "HC") ~ "Hired",
      LAB_TYPE %in% c("FM", "FF", "FC") ~ "Family",
      LAB_TYPE %in% c("EM", "EF", "EC") ~ "Exchange",
      TRUE ~ "Other"
    )
  )
```

### Variable Fertilizer

```{r}
# Créer la variable FERTILIZER qui précise si l'opération a nécessité de l'engrais ou non
Cultivation_cult_distinctes <- Cultivation_cult_distinctes |>
  mutate(FERTILIZER = str_detect(OPERATION, "FERTILIZ|FERTIGATION")) |>
  relocate(FERTILIZER, .after = OPERATION)
```

### Variable Multi-cropping

```{r}
# Créer une variable MULTI_CROPING pour identifier les champs ayant plusieurs cultures sur une même saison
Cultivation_cult_distinctes <- Cultivation_cult_distinctes |>
  group_by(VDS_ID, PLOT_CODE, SEASON, DT_OPER, OPERATION, LAB_TYPE, SUR_MON_YR, NAME_MAT, TYPE_MAT) |>
  mutate(MULTI_CROPING = n() > 1) |>
  ungroup()
```

```{r}
nb_multi_croping <- Cultivation_cult_distinctes |>
  group_by(across(everything())) |>
  filter(MULTI_CROPING) |>
  summarise(nb_multi_croping = n(), .groups = "drop")

nb_champ <- Cultivation_cult_distinctes |>
  group_by(across(everything())) |>
  summarise(nb_champ = n(), .groups = "drop")

cat("Nombre de lignes incluant le multi-croping :", nrow(nb_multi_croping), "\n")
cat("Sur un total de", nrow(nb_champ), "lignes soit", round(100 * nrow(nb_multi_croping) / nrow(nb_champ), 1), "%\n")
```

### Variable Human labor

```{r}
# Créer la variable HUMAN_LABOR à partir de LAB_TYPE
Cultivation_cult_distinctes <- Cultivation_cult_distinctes |>
  mutate(
    HUMAN_LABOR = case_when(
      LAB_TYPE %in% c("HF", "FF", "EF", "HM", "FM", "EM", "FC", "HC", "EC") ~ TRUE,
      TRUE ~ FALSE
    )
  )
```

### Variable Machinery

On se concentre sur la méchanisation du travail. Je crée la variable MACHINERY à partir de TYPE_MAT, qui indique si l'opération est méchanisée. 

L'opération est dite mécanisée si l'une des deux conditions est remplie. 

```{r}
Cultivation_cult_distinctes <- Cultivation_cult_distinctes |>
  mutate(
    MACHINERY = case_when(
      NAME_MAT == "Machinery" |
        NAME_MAT %in% c("TR", "SP", "DS", "SM", "PT", "ET", "CH", "TH", "SD", "MK", "DP") ~ "Mécanisé",
      TRUE ~ "Non mécanisé"
    )
  )
```

Je suppose pour tous les ménages qui n'ont pas indiqué si l'opération était méchanisée ou non (variable NAME_MAT vide), l'opération est non mécanisée. Si on souhaite plutôt mettre n/a, il suffit d'ajouter : is.na(NAME_MAT) ~ NA_character_. 


### Cultures par saison

```{r}
# Modifier la saison dans le cas de cultures annuelles et sélectionner seulement les saisons Kharif et Rabi.
Cultivation_cult_distinctes <- Cultivation_cult_distinctes |>
  mutate(
    SEASON = if_else(CROP %in% c("MANGO", "KAZILIME", "POMOGRANATE", "SUGARCANE", "GUAVA"), "PERENNIAL", SEASON)
  ) |>
  filter(SEASON %in% c("KHARIF", "RABI"))
```

Etudier quelles cultures sont terminées en une saison.

1ère méthode : vérifier que toutes les opérations pour une même culture soient faites dans la même saison (de LAND PREPARATION jusqu'à HARVESTING / THRESHING).

2ème méthode: comparer entre les deux saisons quelles sont les cultures mises en place pour un même champ, incluant SEASONAL FALLOW.

```{r 1ère méthode}
verif_operations <- Cultivation_cult_distinctes |>
  filter(CROP != "SEASONAL FALLLOW") |>
  filter(OPERATION %in% c("HARVESTING", "LAND PREPARATION")) |>
  distinct(VDS_ID, PLOT_CODE, CROP, SEASON, OPERATION) |>
  group_by(VDS_ID, PLOT_CODE, CROP, SEASON) |>
  summarise(n_ops = n_distinct(OPERATION), .groups = "drop") |>
  filter(n_ops > 1)
```
Liste des cultures ayant uniquement une des deux opérations (HARVESTING ou LAND PREPARATION) par saison : JUTE, PILLI PESARA, KOLLA GANJERU, GUVAR GUM, PAPAYA, GAJARJ GRASS, BERSEEM, RABDA

En plus des cultures Perennial/Annual: GRAPE, SUBABUL, BER, POMOGRANATE, LEMON, JASMINE, BANANA, CITRUS, SAPOTA, ARECANUT, GUAVA, MANGO, CUSTARD APPLE, COCONUT, KAZILIME, TURMURIC, SWEET ORANGE, LUCERN GRASS, NAPIER GRASS

```{r 2ème méthode: avec Cultivation_2014}
cultures_per_season <- Cultivation_2014 |>
  filter(SEASON %in% c("KHARIF", "RABI")) |>
  select(VDS_ID, PLOT_CODE, SEASON, CROP_1, CROP_2, CROP_3, CROP_4) |>
  distinct() |>
  group_by(VDS_ID, PLOT_CODE, SEASON) |>
  slice(1) |>  # Garde une seule ligne par champ et saison
  ungroup() |>
  pivot_wider(
    names_from = SEASON,
    values_from = c(CROP_1, CROP_2, CROP_3, CROP_4),
    names_sep = "_"
  ) |>
  mutate(
    diff_crop_1 = CROP_1_KHARIF != CROP_1_RABI,
    diff_crop_2 = CROP_2_KHARIF != CROP_2_RABI,
    diff_crop_3 = CROP_3_KHARIF != CROP_3_RABI,
    diff_crop_4 = CROP_4_KHARIF != CROP_4_RABI,
    has_diff_crop = diff_crop_1 | diff_crop_2 | diff_crop_3 | diff_crop_4
  ) |>
  filter(has_diff_crop) |>
  select(VDS_ID, PLOT_CODE, starts_with("CROP"), has_diff_crop)
```

```{r}
cultures_per_season <- cultures_per_season |>
  select(starts_with("CROP_")) |>
  pivot_longer(cols = everything(), values_to = "CROP") |>
  filter(!is.na(CROP) & CROP != "") |>
  distinct(CROP) |>
  arrange(CROP)
```

Liste des cultures cultivée sur les deux saisons par année (liste faite avec Cultivation_2014) : JUTE, SUNFLOWER, SAFFFLOWER, TOBACCAO, VARIGA, MOONG, BANANA, DRUMSTICK, CASTOR, KAZILIME, GUVAR GUM, MARUA, SWEET POTATO, KOLLA GANJERU, GARLIC, BEANS, GAJRAJ GRASS, PILLI PESARA, MATKI, SARGUJA, CUCUMBER, TEAK, BERSEEM, GUAVA, RABDA

#### Sélectionner les cultures saisonnières

Je sélectionne les cultures qui ont deux récoltes par an, donc deux saisons (Rabi et Kharif), dans le but d'analyser les heures de travail effectués dans chaque culture sur une saison donnée. 

seasonal_crops <- Cultivation_cult_distinctes |>
  distinct(CROP, SEASON) |>
  group_by(CROP) |>
  summarise(nb_saisons = n_distinct(SEASON), .groups = "drop") |>
  filter(nb_saisons > 1)

Cultivation_cult_distinctes <- Cultivation_cult_distinctes |>
  mutate(SEASONAL = CROP %in% seasonal_crops$CROP) |>
  filter(SEASONAL)

FAUX: Cette méthode n'indique pas les cultures saisonnières, mais les cultures avec deux moissons, qui seront donc présentes dans les deux saisons. 

```{r}
seasonal_cultures <- union(verif_operations$CROP, cultures_per_season$CROP)

Cultivation_cult_distinctes <- Cultivation_cult_distinctes |>
  mutate(SEASONAL = CROP %in% seasonal_cultures) |>
  filter(SEASONAL) |>
  select(-SEASONAL)
```

```{r}
# J'enlève la culture GREEN FODDER puisque cela réfère à plusieurs plantes (sorghum, maize, oats). Certaines de ces plantes sont sur une saison, d'autres sur une année, donc je peux pas catégoriser GREEN FODDER. 
Cultivation_cult_distinctes <- Cultivation_cult_distinctes |>
  filter(CROP != "GREEN FODDER")
```


#### Graph: Nombre de champs par culture et par saison

Combien de champs y a-t-il par culture et par saison ? 

```{r}
cultures_per_season <- Cultivation_cult_distinctes |>
  distinct(VDS_ID, PLOT_CODE, SEASON, CROP) |>
  group_by(SEASON, CROP) |>
  summarise(NB_PLOTS = n(),
            .groups = "drop")
```

```{r}
cultures_per_season |>
  filter(CROP %in% c("PADDY", "WHEAT", "MAIZE", "COTTON", "SOYBEAN", "SORGHUM", "CHICKPEA", "BLACK GRAM", "GROUNDNUT", "ONION")) |>
  ggplot(aes(x = CROP, y = NB_PLOTS, fill = SEASON)) +
  geom_bar(stat = "identity", position = position_dodge(width = 0.7), width = 0.6) +
  labs(
    title = "Nombre de champs par culture selon la saison",
    x = "",
    y = "",
    fill = ""
  ) +
  coord_flip() +
  theme_minimal() +
  theme(
    axis.text.x = element_text(size = 9)
  )
```


## Verifs

### Enquêtes par ménage

On vérifie comment a été remplie la variable OPERATION, variable mensuelle.
Est-ce qu'il y a exactement 12 enquêtes (SUR_MON_YR) faites par ménage (identifié par VDS_ID) en 2014 ? 

```{r}
test_nb_survey <- Cultivation_cult_distinctes |>
  distinct(VDS_ID, SUR_MON_YR) |> 
  count(VDS_ID, name = "nb_survey")
```

```{r}
test_nb_survey |>
  ggplot(aes(x = nb_survey)) +
  geom_bar(fill = "seagreen3", width = 0.7) +
  geom_text(stat = "count", aes(label = ..count..), vjust = -0.4) +
  scale_x_continuous(
    breaks = seq(0, 12, by = 1) 
  ) +
  labs(
    title = "Nombre d'enquêtes faites par ménage",
    x = ""
  ) +
  theme_minimal()
```


### Enquêtes par mois

On vérifie sur quels mois ont été faites les enquêtes à partir de la variable MONTH.

Le graphique suivant montre le nombre d'enquêtes par mois en considèrant les ménages distincts (soit une enquête maximum par ménage et par mois).

```{r}
month_levels <- c("janv", "feb", "march", "april", "may", "june", 
                  "july", "aug", "sept", "oct", "nov", "dec")

test_nb_survey <- Cultivation_cult_distinctes |>
  group_by(MONTH) |> 
  count(VDS_ID, name = "nb_survey") |>
  mutate(MONTH = factor(MONTH, levels = month_levels, ordered = TRUE))
```

```{r}
test_nb_survey |>
  ggplot(aes(x = nb_survey, y = MONTH)) +
  geom_col(fill = "darkgreen", width = 0.7) +
  coord_flip() +
  scale_x_continuous() +
  labs(
    title = "Nombre d'enquêtes faites par mois (ménages distincts)",
    x = "",
    y = ""
  ) +
  theme_minimal()
```
On constate que les enquêtes faites auprès des ménages sont plus nombreuses lors des mois avec le plus de travail (juillet, août), au contraire des mois creux (mai, juin). Cela justifie l'hypothèse que les opérations ne sont pas indiquées comme vide lorsqu'aucun travail n'est fait. 

#### Selon les saisons

Je refais le même graphique séparement pour les champs en Kharif et ceux en Rabi. 

```{r Kharif}
test_nb_survey <- Cultivation_cult_distinctes |>
  filter(SEASON == "KHARIF") |>
  group_by(MONTH) |> 
  count(VDS_ID, name = "nb_survey") |>
  mutate(MONTH = factor(MONTH, levels = month_levels, ordered = TRUE))

test_nb_survey |>
  ggplot(aes(x = nb_survey, y = MONTH)) +
  geom_col(fill = "darkgreen", width = 0.7) +
  coord_flip() +
  scale_x_continuous() +
  labs(
    title = "Kharif- Nombre d'enquêtes faites par mois (ménages distincts)",
    x = "",
    y = ""
  ) +
  theme_minimal()
```

```{r Rabi}
test_nb_survey <- Cultivation_cult_distinctes |>
  filter(SEASON == "RABI") |>
  group_by(MONTH) |> 
  count(VDS_ID, name = "nb_survey") |>
  mutate(MONTH = factor(MONTH, levels = month_levels, ordered = TRUE))

test_nb_survey |>
  ggplot(aes(x = nb_survey, y = MONTH)) +
  geom_col(fill = "darkgreen", width = 0.7) +
  coord_flip() +
  scale_x_continuous() +
  labs(
    title = "Rabi- Nombre d'enquêtes faites par mois (ménages distincts)",
    x = "",
    y = ""
  ) +
  theme_minimal()
```


********************************************************************************

## Modifier Cultivation : créer les lignes pour les opérations non complétées

On estime que si une opération n'est pas complétée pour un mois et un champ donnés, alors son temps de travail est égal à 0. Le but est de créer une base qui indique WORK_HR = 0 pour toutes les opérations pas complétées pour un mois (MONTH) et un champ donnée (VDS_ID, PLOT_CODE, SEASON)

*Version sans Month*

La base full_operation regroupe tous les couples existants VDS_ID / PLOT_CODE / CROP / SEASON (pour identifier de façon unique un champ) en ajoutant les combinaisons possibles de OPERATION.

J'ajoute d'autres variables qui ne servent pas à identifier le champ mais que je souhaite indiquer dans tous les lignes d'un même champ. 

```{r}
plots_by_household <- Cultivation_cult_distinctes |>
  distinct(VDS_ID, PLOT_CODE, SEASON, CROP, CROP_ID, AREA_CROP, IRRI_CROP, VAR_TYPE, VAR_NAME, MULTI_CROPING, REGION, STATE, VILLAGE)

full_operation <- expand_grid(
  plots_by_household,
  OPERATION = unique(Cultivation_cult_distinctes$OPERATION)
)
```

Avec le code suivant, les doublons sont bien conservés puisque toutes les lignes sont repliquées dans le cas de doublons avec le couple (VDS_ID, PLOT_CODE, CROP, SEASON, OPERATION).

```{r, message=FALSE, warning=FALSE}
base_to_join <- Cultivation_cult_distinctes |>
  select(
    VDS_ID, PLOT_CODE, SEASON, CROP, OPERATION,
    MONTH, GENDER, EMPLOYMENT, HUMAN_LABOR, MACHINERY, DT_OPER, SUR_MON_YR,
    FERTILIZER, LAB_TYPE, WORK_HR, OP_MAIN_PROD_UNIT, OP_MAIN_PROD_QTY, NAME_MAT, TYPE_MAT, MACHINERY
  )

# Jointure sans conflit de colonnes
Cultivation_expand <- full_operation |>
  left_join(base_to_join, by = c("VDS_ID", "PLOT_CODE", "SEASON", "CROP", "OPERATION")) |>
  mutate(WORK_HR = replace_na(WORK_HR, 0))
```


Les prochains test visent à inclure MONTH dans la base Cultivation_expand. 

*1er test: Créer des lignes pour tous les mois (même manquants)*

Je regroupe toutes les combinaisons possibles de MONTH / OPERATION et tous les couples existants VDS_ID / PLOT_CODE.

Pas besoin d'ajouter SEASON pour identifier le champs parce qu'on a déjà le mois qui sous-entend donc la saison ? Faux car les deux saisons se superposent sur certains mois

```{r}
plots_by_household <- Cultivation_cult_distinctes |>
  distinct(VDS_ID, PLOT_CODE)

full_operation <- expand_grid(
  plots_by_household,
  MONTH = unique(Cultivation_cult_distinctes$MONTH),
  OPERATION = unique(Cultivation_cult_distinctes$OPERATION)
)
```

Puis l'idée de créer la base Cultivation_expand en joignant avec "MONTH", "VDS_ID", "PLOT_CODE", "OPERATION"

Ma méthode de faire pour tous les mois est fausse, parce que certains champs n'existent que pour une saison donnée, notamment en jachère ? donc associer un WORK_HR = 0 à ces champs revient à créer des valeurs qui n'existent pas

*2ème test: Créer des lignes seulement pour les mois existants*

Je refais la base full_operations en identifiant les champs existants par les variables (VDS_ID, PLOT_CODE, SEASON, MONTH)

Ce choix repose sur l'hypothèse qu'un champ qui n'a pas fait une opération en un mois est un champ en jachère. Mais ça peut être faux si on voit des champs cultivés les mois précédents et suivants (ex: nov, janv sans dec)

et faux si l'enquête n'a pas été faite pendant un mois entier (mais dans ce cas, faut mieux supposer NA que mettre 0 qui n'est pas nécessairement juste)

```{r}
plots_by_household <- Cultivation_cult_distinctes |>
  distinct(VDS_ID, PLOT_CODE, SEASON, MONTH)

full_operation <- expand_grid(
  plots_by_household,
  OPERATION = unique(Cultivation_cult_distinctes$OPERATION)
)
```

Dans ce cas, je joindrais Cultivation_cult_distinctes et full_operation2 avec "MONTH", "VDS_ID", "PLOT_CODE", "SEASON", "OPERATION"


********************************************************************************

## Ajout de la caste à la base Cultivation_expand

### Joindre les deux régions de la base Household_info

J'importe les tables Household_info des deux régions (EAST et SAT) pour l'année 2014, pour intégrer la variable CASTE à chaque ménage. 

```{r, message=FALSE, warning=FALSE}
EAST_Household_info <- read_excel(here::here("raw_data", "EAST_Household_info_2014.xlsx"))
SAT_Household_info <- read_excel(here::here("raw_data", "SAT_Household_info_2014.xlsx"))
```

```{r}
# Sélectionner les variables VDS_ID et CASTE pour chaque table 
EAST_Household_info <- EAST_Household_info |>
  select(VDS_ID, CASTE, CASTE_GROUP)

SAT_Household_info <- SAT_Household_info |>
  select(VDS_ID, CASTE, CASTE_CATEGORY) |>
  rename(CASTE_GROUP = CASTE_CATEGORY)

# Joindre les deux régions
Household_info <- bind_rows(EAST_Household_info, SAT_Household_info)
```


### Vérifier la correspondance de VDS_ID

Les identifiants des ménages ne correspondent pas entre les deux bases, parce que dans la base Household_info, VDS_ID est majoritairement indiqué pour l'année 2013 plutôt que 2014. 

```{r}
Household_info <- Household_info |>
  mutate(VDS_ID = ifelse(substr(VDS_ID, 5, 5) != "4",
                         paste0(substr(VDS_ID, 1, 4), "4", substr(VDS_ID, 6, nchar(VDS_ID))),
                         VDS_ID))
```

Je vérifie la correspondance des ménages entre Cultivation_expand et Household_info, une fois les années harmonisées. 

```{r Correspondance Cultivation_expand -> Household_info}
household_keys <- Household_info |>
  select(VDS_ID) |>
  distinct()

cultivation_keys <- Cultivation_expand |>
  select(VDS_ID) |>
  distinct()

# Identifier les ménages de Cultivation_expand non trouvés dans Household_info
non_match <- anti_join(cultivation_keys, household_keys, by = "VDS_ID")

n_non_matched <- nrow(non_match)
n_hh <- nrow(cultivation_keys)
prop_non_matched <- round(n_non_matched / n_hh * 100, 2)

cat(" - Ménages totaux dans Cultivation_expand :", n_hh, "\n")
cat(" - Ménages sans équivalent dans Household_info :", n_non_matched, "\n")
cat(" - Proportion sans équivalent :", prop_non_matched, "%\n")
```

```{r Correspondance des régions}
# Faire ressortir les codes de chaque village pour comparer les bases
household_village <- Household_info |> 
  mutate(VILLAGE = substr(VDS_ID, 2, 3)) |>
  group_by(VILLAGE) |>
  distinct(VDS_ID) |>
  summarise(n = n(), .groups = "drop")

nb_village  <- Cultivation_expand  |> 
  mutate(VILLAGE = substr(VDS_ID, 2, 3)) |>
  group_by(VILLAGE) |>
  distinct(VDS_ID) |>
  summarise(n = n(), .groups = "drop")
```

Le village TS, qui comprend 64 ménages dans Cultivation_expand, n'est pas présent dans Household_info, ce qui explique une partie des ménages manquants. 


### Caste + Caste_group

```{r}
Cultivation_expand <- Cultivation_expand |>
  left_join(Household_info |> select(VDS_ID, CASTE, CASTE_GROUP), by = "VDS_ID") |>
  mutate(
    CASTE_GROUP = recode(CASTE_GROUP, 
                         `OBC` = "BC", `EBC` = "BC", `SBC` = "BC", `SBC/SEBC/EBC` = "BC", `NT` = "OTHER", `Minorities` = "OTHER", `VJ` = "OTHER"),
    )
```

Je regarde le nombre de n/a pour la caste dans Cultivation.  

```{r}
Cultivation_expand |>
  summarise(
    na_caste = sum(is.na(CASTE_GROUP)),
    total = n(),
    pct_na = round(100 * na_caste / total, 2)
  )
```

### Irrigation

```{r}
# Variable IRRIGATION
Cultivation_expand <- Cultivation_expand |>
  mutate(PER_IRRI = round(100 * IRRI_CROP / AREA_CROP, 2)) |>
  mutate(PER_IRRI = if_else(PER_IRRI>100, 100, PER_IRRI))

Cultivation_expand <- Cultivation_expand |>
  mutate(
    IRRIGATION = case_when(
      PER_IRRI>49 ~ "Irrigué",
      PER_IRRI<50 ~ "Non irrigué"
    )
  ) |>
  select(-PER_IRRI)
```


### Ordre des variables

```{r}
Cultivation_expand <- Cultivation_expand |>
  select(
    SUR_MON_YR, MONTH, SEASON, VDS_ID, CASTE, CASTE_GROUP, PLOT_CODE, AREA_CROP, IRRI_CROP, CROP, IRRIGATION, DT_OPER, OPERATION, LAB_TYPE, WORK_HR, GENDER, EMPLOYMENT, NAME_MAT, TYPE_MAT, OP_MAIN_PROD_UNIT, OP_MAIN_PROD_QTY, MACHINERY, FERTILIZER, VAR_TYPE, VAR_NAME, CROP_ID, HUMAN_LABOR, MULTI_CROPING, REGION, STATE, VILLAGE, everything()  # place les colonnes restantes à la fin
  )
```


********************************************************************************

## Ajouter les champs en jachère par saison

### Modifier Plot_code : unicité des champs

Je repère les champs pour lesquels les variables VDS_ID, PLOT_CODE et SEASON ne sont pas suffisantes pour les identifier de façon unique et qui doivent être différenciés avec CROP. 

```{r}
# Tableau des champs nécessitant CROP pour les identifier
dup_crop <- Cultivation_expand |>
  select(VDS_ID, PLOT_CODE, SEASON, CROP, AREA_CROP) |>
  distinct() |>
  group_by(VDS_ID, PLOT_CODE, SEASON, AREA_CROP) |>
  filter(n() > 1) |>
  mutate(row_in_group = row_number()) |> 
  ungroup()
```

Pour ces 3 champs, je modifie PLOT_CODE, pour identifier ces champs de façon unique.

CE CODE CREE DES LIGNES EN DOUBLE POUR LE MOMENT!

dup_crop <- dup_crop |>
  mutate(PLOT_CODE_NEW = ifelse(row_in_group == 2, "Z", PLOT_CODE)) |>
  select(VDS_ID, CROP, SEASON, AREA_CROP, PLOT_CODE, PLOT_CODE_NEW)

test_cultivation_expand <- Cultivation_expand |>
  left_join(dup_crop, by = c("VDS_ID", "CROP", "SEASON", "PLOT_CODE", "AREA_CROP")) |>
  mutate(PLOT_CODE = coalesce(PLOT_CODE_NEW, PLOT_CODE)) |>
  select(-PLOT_CODE_NEW)


```{r}
# Tableau des champs en double à cause de VAR_TYPE
dup_var_type <- Cultivation_expand |>
  select(VDS_ID, PLOT_CODE, SEASON, CROP, AREA_CROP, VAR_TYPE, VAR_NAME) |>
  distinct() |>
  group_by(VDS_ID, PLOT_CODE, SEASON, CROP, AREA_CROP) |>
  filter(n() > 1) |>
  mutate(row_in_group = row_number()) |> 
  ungroup()
```

Pour ces 4 champs en double à cause de VAR_TYPE, je modifie PLOT_CODE, pour identifier ces champs de façon unique.

```{r}
dup_var_type <- dup_var_type |>
  mutate(PLOT_CODE_NEW = ifelse(row_in_group == 2, "ZZ", PLOT_CODE)) |>
  select(VDS_ID, CROP, SEASON, AREA_CROP, VAR_TYPE, VAR_NAME, PLOT_CODE, PLOT_CODE_NEW)

Cultivation_expand <- Cultivation_expand |>
  left_join(dup_var_type, by = c("VDS_ID", "CROP", "SEASON", "PLOT_CODE", "AREA_CROP", "VAR_TYPE", "VAR_NAME")) |>
  mutate(PLOT_CODE = coalesce(PLOT_CODE_NEW, PLOT_CODE)) |>
  select(-PLOT_CODE_NEW)
```



### Verif: Superficie des champs entre les saisons

On veut vérifier si la superficie d'un même champ diffère entre deux saisons (au cas où les champs serainet consolidés d'une saison à une autre). 

Pour cela, je pivote en large la base selon la saison (pour les variables AREA_CROP et CROP). Le but est d'indiquer les potentielles différences de superficie d'un champ entre les saisons et de repérer les champs manquants (donc en jachère). 


Problème: Les couples (VDS_ID, PLOT_CODE, CROP, SEASON, AREA_CROP) ne sont pas uniques. Cela signifie que des champs ont plusieurs valeurs de AREA_CROP pour la même saison et culture.

En regardant la base Cultivation_2014 (avant d'avoir pivoter en long les cultures et calculer ARE_CROP en pourcentage de PLOT_AREA), on voit qu'il y a seulement 3 champs (VDS_ID et PLOT_CODE) qui ont des superficies différentes (même avec CROP, VAR_NAME et VAR_TYPE identiques). 

Les autres doublons présents dans Cultivation_expand sont dûs à des différences dans VAR_NAME ET VAR_TYPE, donc correspondent à des champs distincts. Je modifie donc PLOT_CODE pour distinguer ces champs. 

```{r}
# Champs ayant plusieurs valeurs de AREA_CROP pour la même saison
dup_champs_area <- Cultivation_expand |>
  distinct(VDS_ID, PLOT_CODE, SEASON, AREA_CROP, VAR_NAME, VAR_TYPE, CROP) |>
  group_by(VDS_ID, PLOT_CODE, SEASON) |>
  filter(n() > 1) |>
  arrange(VDS_ID, PLOT_CODE, SEASON, AREA_CROP, VAR_NAME, VAR_TYPE, CROP) |>
  mutate(row_in_group = row_number()) |> 
  ungroup()
```

```{r}
dup_champs_area <- dup_champs_area |>
  mutate(
    PLOT_CODE_NEW = case_when(
      row_in_group == 2 ~ paste0(PLOT_CODE, "X"),
      row_in_group == 3 ~ paste0(PLOT_CODE, "Y"),
      row_in_group == 4 ~ paste0(PLOT_CODE, "Z"),
      TRUE ~ PLOT_CODE
    )
    ) |>
  select(VDS_ID, VAR_NAME, AREA_CROP, VAR_TYPE, CROP, SEASON, PLOT_CODE, PLOT_CODE_NEW)

cultivation_wider_season <- Cultivation_expand |>
  left_join(dup_champs_area, by = c("VDS_ID", "VAR_NAME", "AREA_CROP", "CROP", "VAR_TYPE", "SEASON", "PLOT_CODE")) |>
  mutate(PLOT_CODE = coalesce(PLOT_CODE_NEW, PLOT_CODE)) |>
  select(-PLOT_CODE_NEW)
```

FAUX: car si on somme tous les champs d'un ménage par saison, on voit que pour la très grande majorité (tous excepté 2 champs) les superficies sont égales entre les deux saisons. Donc, les champs ayant indiqué FALSE dans la partie précédente sont juste de la consolidation de champs parmi le même ménage. 

Il n'y a donc pas besoin de créer de champs en jachère. 


#### Test: Variation de la superficie des champs par saison

```{r}
cultivation_wider_season <- cultivation_wider_season |>
  distinct(VDS_ID, PLOT_CODE, SEASON, AREA_CROP) |>
  pivot_wider(
    names_from = SEASON,
    values_from = AREA_CROP
  ) |>
  mutate(diff_area = KHARIF != RABI)

cat("Champs avec une superficie qui varie par saison :", nrow(cultivation_wider_season |> filter(diff_area)), "\n")
cat("Sur un total de", nrow(cultivation_wider_season), "champs soit", round(100 * nrow(cultivation_wider_season |> filter(diff_area)) / nrow(cultivation_wider_season), 1), "%\n")
```

QUESTION: 

Est-ce que je peux ajouter les champs en jachère seulement pour les ménages qui n'ont indiqué qu'une seule saison ? donc quand diff_area = n/a ? 


#### Tests: Somme des superficies des champs du ménage par saison

```{r}
test_area_hh_1 <- Cultivation_expand |>
  distinct(VDS_ID, PLOT_CODE, AREA_CROP, SEASON, VAR_TYPE, VAR_NAME, CROP) |>
  group_by(VDS_ID, SEASON) |>
  summarise(hh_area = sum(AREA_CROP, na.rm = TRUE), .groups = "drop") |>
  pivot_wider(
    names_from = SEASON,
    values_from = hh_area
  ) |>
  mutate(diff_area = KHARIF != RABI)

mean_area_1 <- test_area_hh_1 |>
  summarise(
    mean(KHARIF, na.rm = TRUE),
    mean(RABI, na.rm = TRUE)
    )                               

cat("Ménages avec une surface des champs différente selon la saison :", nrow(test_area_hh_1 |> filter(diff_area)), "\n")
cat("Sur un total de", nrow(test_area_hh_1), "ménages soit", round(100 * nrow(test_area_hh_1 |> filter(diff_area)) / nrow(test_area_hh_1), 1), "%\n")
```

```{r}
test_area_hh_2 <- cultivation_wider_season |>
  group_by(VDS_ID) |>
  summarise(
    area_kharif = sum(KHARIF, na.rm = TRUE),
    area_rabi = sum(RABI, na.rm = TRUE), .groups = "drop") |>
  mutate(diff_area = area_kharif != area_rabi)

mean_area_2 <- test_area_hh_2 |>
  summarise(
    mean(area_kharif, na.rm = TRUE),
    mean(area_rabi, na.rm = TRUE)
    )

cat("Ménages avec une surface des champs différente selon la saison :", nrow(test_area_hh_2 |> filter(diff_area)), "\n")
cat("Sur un total de", nrow(test_area_hh_2), "ménages soit", round(100 * nrow(test_area_hh_2 |> filter(diff_area)) / nrow(test_area_hh_2), 1), "%\n")
```

--> La différence dans les résultats entre la table Cultivation_expand et cultivation_wider_season vient du calcul de la superficie total par ménage et par saison, plutôt que la modification de PLOT_CODE. En ne faisant pas pivoter cultivation_wider_season, on a un % identique à celui de Cultivation_expand. 





### Compter les ménages/champs par saison

On compte les ménages et champs présents par saison. 
Attention, ils sont comptabilisés deux fois (une fois par saison). 

```{r}
Cultivation_expand |>
  summarise(
    `Nombre de ménages` = n_distinct(VDS_ID),
    `Nombre de champs` = n_distinct(paste(VDS_ID, PLOT_CODE, SEASON, sep = "_"))
  ) |>
  gt() |>
  tab_header(
    title = "Ménages et champs par saison"
  )
```


### Ménages/champs dans une seule saison

J'identifie ensuite les ménages et champs présents dans une seule saison. 

```{r}
# Identifier les champs uniques par saison
champs_kharif <- Cultivation_expand |>
  filter(SEASON == "KHARIF") |>
  distinct(VDS_ID, PLOT_CODE)

champs_rabi <- Cultivation_expand |>
  filter(SEASON == "RABI") |>
  distinct(VDS_ID, PLOT_CODE)

# KHARIF mais pas RABI
uniques_kharif <- anti_join(champs_kharif, champs_rabi,
                            by = c("VDS_ID", "PLOT_CODE"))

# RABI mais pas KHARIF
uniques_rabi <- anti_join(champs_rabi, champs_kharif,
                          by = c("VDS_ID", "PLOT_CODE"))

# Présents dans les deux saisons
present_both <- inner_join(champs_kharif, champs_rabi, by = c("VDS_ID", "PLOT_CODE"))
```

```{r}
bind_rows(
  uniques_kharif |>
    summarise(Saison = "KHARIF seulement", `Nombre de champs` = n()),
  uniques_rabi |>
    summarise(Saison = "RABI seulement", `Nombre de champs` = n()),
  present_both |>
    summarise(Saison = "KHARIF et RABI", `Nombre de champs` = n())
) |>
  gt() |>
  tab_header(title = "Champs présents dans une seule saison") |>
  cols_label(
    Saison = "Saison",
    `Nombre de champs` = "Champs uniques"
  )
```

Pour retomber sur le total de 3 956 champs distincts, additionner Kharif seulement + Rabi seulement + (Kharif et Rabi x 2)





### Ajouter les champs en jachère

VOIR SI GARDER: RESULTAT FAUX POUR L'INSTANT

Il faut ajouter 588 champs en jachère en Kharif et 1 726 en Kharif. Le nombre total de champs pour les deux saisons sera alors 3 135 champs par saison. 

```{r}
full_season <- expand_grid(
  Cultivation_expand |> distinct(VDS_ID, PLOT_CODE),
  SEASON = unique(Cultivation_expand$SEASON)
)

test_cultivation_expand <- full_season |>
  left_join(Cultivation_expand, by = c("VDS_ID", "PLOT_CODE", "SEASON")) |>
  mutate(
    CROP = replace_na(CROP, "SEASONAL FALLOW")
    )
```

Conserver les variables sur le ménage pour les champs en jachère : 

```{r}
test_cultivation_expand <- Cultivation_expand |>
  group_by(VDS_ID) |>
  mutate(CASTE_GROUP = if (any(!is.na(CASTE_GROUP))) first(na.omit(CASTE_GROUP)) else NA_character_,
        CASTE = if (any(!is.na(CASTE))) first(na.omit(CASTE)) else NA_character_,
        AREA_CROP   = if (any(!is.na(AREA_CROP)))   first(na.omit(AREA_CROP))   else NA_real_,
        IRRI_CROP   = if (any(!is.na(IRRI_CROP)))   first(na.omit(IRRI_CROP))   else NA_real_,
        IRRIGATION  = if (any(!is.na(IRRIGATION)))  first(na.omit(IRRIGATION))  else NA_character_,
        STATE       = if (any(!is.na(STATE)))       first(na.omit(STATE))       else NA_character_,
        VILLAGE     = if (any(!is.na(VILLAGE)))     first(na.omit(VILLAGE))     else NA_character_,
        REGION      = if (any(!is.na(REGION)))      first(na.omit(REGION))      else NA_character_
  ) |>
  ungroup()
```



********************************************************************************

## Liens extérieurs

### Enregistrer Cultivation_cult_distinctes dans le document partagé

```{r}
# Test final des doublons avant d'enregistrer
dup_plots <- Cultivation_expand |>
  select(VDS_ID, PLOT_CODE, SEASON, CROP, AREA_CROP, VAR_TYPE, VAR_NAME, REGION, STATE, VILLAGE, CASTE_GROUP, IRRI_CROP, IRRIGATION, CROP_ID) |>
  distinct() |>
  group_by(VDS_ID, PLOT_CODE, SEASON, AREA_CROP) |>
  filter(n() > 1) |>
  mutate(row_in_group = row_number()) |> 
  ungroup()
```

```{r}
# Seulement paddy en Kharif
dup_plots_paddy <- Cultivation_expand |>
  filter(SEASON == "KHARIF", CROP == "PADDY") |>
  select(VDS_ID, PLOT_CODE, SEASON, CROP, AREA_CROP, VAR_TYPE, VAR_NAME, REGION, STATE, VILLAGE, CASTE_GROUP, IRRI_CROP, IRRIGATION, CROP_ID) |>
  distinct() |>
  group_by(VDS_ID, PLOT_CODE, AREA_CROP) |>
  filter(n() > 1) |>
  mutate(row_in_group = row_number()) |> 
  ungroup()
```


```{r}
# Définir le chemin du dossier
folder_path <- "C:/Users/documentation/OneDrive - Université Paris-Dauphine/CDD projet Inde/Data sources/R Project- Micro database/Base de données générées/Cultivation_cult_distinctes"

# Créer le dossier s'il n'existe pas
if (!dir.exists(folder_path)) {
  dir.create(folder_path, recursive = TRUE)
}

# Enregistrer le fichier CSV
write.csv(
  Cultivation_cult_distinctes,
  file = file.path(folder_path, "Cultivation_cult_distinctes.csv"),
  row.names = FALSE
)

# Enregistrer le fichier RDS
saveRDS(
  Cultivation_cult_distinctes,
  file = file.path(folder_path, "Cultivation_cult_distinctes.rds"),
)
```

### Enregistrer Cultivation_expand dans le document partagé

```{r}
# Définir le chemin du dossier
folder_path <- "C:/Users/documentation/OneDrive - Université Paris-Dauphine/CDD projet Inde/Data sources/R Project- Micro database/Base de données générées/Cultivation_expand"

# Créer le dossier s'il n'existe pas
if (!dir.exists(folder_path)) {
  dir.create(folder_path, recursive = TRUE)
}

# Enregistrer le fichier CSV
write.csv(
  Cultivation_expand,
  file = file.path(folder_path, "Cultivation_expand.csv"),
  row.names = FALSE
)

# Enregistrer le fichier RDS
saveRDS(
  Cultivation_expand,
  file = file.path(folder_path, "Cultivation_expand.rds"),
)
```

