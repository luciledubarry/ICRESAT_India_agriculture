---
title: "Fichier 1 : Créer la base Cultivation 2014"
format: html
editor: source
---

```{r}
#| message: false
rm(list = ls())
graphics.off()
cat("\014")
```

```{r}
#| message: false
here::i_am("ICRESAT_database_analysis/scripts_2014/CultData1_merging_2014.qmd")
library(dplyr)
library(tidyr)
library(knitr)
library(readxl)
library(stringr)
library(stringdist)
library(ggplot2)
library(here)
```


********************************************************************************

# Nettoyage des bases

## Importer les données

```{r Importer les données, message=FALSE, warning=FALSE}
EAST_CultInput_2014 <- read_excel(here::here("raw_data", "EAST_CultInput_2014.xlsx"))
SAT_CultInput_2014  <- read_excel(here::here("raw_data", "SAT_CultInput_2014.xlsx"))
EAST_CultOutput_2014 <- read_excel(here::here("raw_data", "EAST_CultOutput_2014.xlsx"))
SAT_CultOutput_2014  <- read_excel(here::here("raw_data", "SAT_CultOutput_2014.xlsx"))
EAST_PlotList_2014 <- read_excel(here::here("raw_data", "EAST_PlotList_2014.xlsx"))
SAT_PlotList_2014 <- read_excel(here::here("raw_data", "SAT_PlotList_2014.xlsx"))
EAST_Landholding_2014 <- read_excel(here::here("raw_data", "EAST_Landholding_2014.xlsx"))
SAT_Landholding_2014 <- read_excel(here::here("raw_data", "SAT_Landholding_2014.xlsx"))
```


## Rassembler par région

J'ajoute dans la base CultInput une variable pour identifier de quelle région proviennent les données. 

```{r Création la variable REGION}
SAT_CultInput_2014 <- SAT_CultInput_2014 |>
  mutate(REGION = "SAT")
  
EAST_CultInput_2014 <- EAST_CultInput_2014 |>
  mutate(REGION = "EAST")
```

```{r Harmoniser les noms des variables}
EAST_CultOutput_2014 <- EAST_CultOutput_2014 |>
  rename(CROP_AREA = PLOT_AREA)
SAT_CultOutput_2014 <- SAT_CultOutput_2014 |>
  rename(CROP_AREA = PLOT_AREA)

EAST_CultInput_2014 <- EAST_CultInput_2014 |>
  rename(CROP_AREA = PLOT_AREA)
SAT_CultInput_2014 <- SAT_CultInput_2014 |>
  rename(CROP_AREA = PLOT_AREA)

names(EAST_Landholding_2014) <- toupper(names(EAST_Landholding_2014))
EAST_Landholding_2014 <- EAST_Landholding_2014 |>
  rename(VDS_ID = VDSID)
```

Attention: PLOT_AREA désigne la superficie du plot et CROP_AREA celle du subplot (égale au plot s'il n'y a pas de division du champ). Idem, PLOT_CODE désigne l'identifiant du plot et SUB_PLOT_CODE l'identifiant du subplot. 

```{r Harmoniser les types de chaque colonne}
# Je repère si les colonnes ayant le même nom et vérifie si elles sont du même type  (numeric ou character). Si ce n'est pas le cas, je les convertis en character, ce qui limite le nombre de NA. Il est nécessaire que les colonnes soient du même type pour utiliser la fonction bind_rows. 

common_cols_cultinput <- intersect(names(EAST_CultInput_2014), names(SAT_CultInput_2014))
for (col in common_cols_cultinput) {
    EAST_CultInput_2014[[col]] <- as.character(EAST_CultInput_2014[[col]])
    SAT_CultInput_2014[[col]] <- as.character(SAT_CultInput_2014[[col]])
}

common_cols_cultoutput <- intersect(names(EAST_CultOutput_2014), names(SAT_CultOutput_2014))
for (col in common_cols_cultoutput) {
    EAST_CultOutput_2014[[col]] <- as.character(EAST_CultOutput_2014[[col]])
    SAT_CultOutput_2014[[col]] <- as.character(SAT_CultOutput_2014[[col]])
}

common_cols_plotlist <- intersect(names(EAST_PlotList_2014), names(SAT_PlotList_2014))
for (col in common_cols_plotlist) {
    EAST_PlotList_2014[[col]] <- as.character(EAST_PlotList_2014[[col]])
    SAT_PlotList_2014[[col]] <- as.character(SAT_PlotList_2014[[col]])
}

common_cols_landholding <- intersect(names(EAST_Landholding_2014), names(SAT_Landholding_2014))
for (col in common_cols_landholding) {
    EAST_Landholding_2014[[col]] <- as.character(EAST_Landholding_2014[[col]])
    SAT_Landholding_2014[[col]] <- as.character(SAT_Landholding_2014[[col]])
}
```

```{r}
CultInput_2014 <- bind_rows(EAST_CultInput_2014, SAT_CultInput_2014) |>
  mutate(SUR_YEAR = 2014)
CultOutput_2014 <- bind_rows(EAST_CultOutput_2014, EAST_CultOutput_2014)|>
  mutate(SUR_YEAR = 2014)
PlotList_2014 <- bind_rows(EAST_PlotList_2014, SAT_PlotList_2014)
Landholding_2014 <- bind_rows(EAST_Landholding_2014, SAT_Landholding_2014)
```


********************************************************************************

## Tests avant toutes modifications

### NA pour Lab_type et Work_hr 

Je regarde combien de NA ont les variables LAB_TYPE et WORK_HR, et sur quelles opérations sont répartis ces NA. 

```{r}
na_LAB_TYPE <- nrow(CultInput_2014 |> filter(is.na(LAB_TYPE)))
na_WORK_HR <- nrow(CultInput_2014 |> filter(is.na(WORK_HR)))

cat(" - N/a dans LAB_TYPE :", na_LAB_TYPE, "soit", round(100 * na_LAB_TYPE / nrow(CultInput_2014), 1), "% de la base CultInput \n")
cat(" - N/a dans WORK_HR :", na_WORK_HR, "soit", round(100 * na_WORK_HR / nrow(CultInput_2014), 1), "% de la base CultInput \n")
```

Refaire ce tableau après l'harmonisation des noms d'opérations !!

```{r}
test_oper <- CultInput_2014 |>
  filter(is.na(WORK_HR)) |>
  count(OPERATION, sort = TRUE) 

test_oper |>
  slice_max(n, n = 10) |>
  select(OPERATION, n) |>
  kable(
    caption = "Opérations avec le plus de n/a pour WORK_HR",
    col.names = c("Opération", "Nombre de n/a")
  )
```

### Crop damage 

Je regarde combien de cultures ont été arrêtées en cours de saison (crop damage), à partir des remarques mises dans la base CultOutput. 

```{r, warning=FALSE}
crop_damage <- CultOutput_2014 |> 
  summarise(CROP_DAMAGE = str_detect(REMARKS, "DAMAGE|DESTROI|DAMGED"))

cat(" Nombre de crop damage :", nrow(crop_damage |> filter(CROP_DAMAGE == TRUE)), "\n")
```

Autre technique : Dans le questionnaire, si le champ est perdu, l'inspecteur doit indiquer un temps de travail nul pour la récolte et une production nulle (dans Cult_Output). Je regarde combien de champs ont un temps de travail pour Harvesting égal à 0 dans CultInput.

```{r}
crop_damage <- CultInput_2014 |>
  mutate(HARVEST = str_detect(OPERATION, "Harves|HARVES")) |>
  filter(HARVEST == TRUE) |>
  filter(WORK_HR == 0 | is.na(WORK_HR))

cat(" Nombre de potentiel crop damage :", nrow(crop_damage), "\n")
```
Ces 39 lignes ont WORK_HR = NA. 


### Enregistrer PlotList_2014 avant modification

```{r}
# Définir le chemin du dossier
folder_path <- here("Base de données générées", "PlotList_2014")

# Créer le dossier s'il n'existe pas
if (!dir.exists(folder_path)) {
  dir.create(folder_path, recursive = TRUE)
}

# Enregistrer le fichier CSV
write.csv(
  PlotList_2014,
  file = file.path(folder_path, "PlotList_2014.csv"),
  row.names = FALSE
)

# Enregistrer le fichier RDS
saveRDS(
  PlotList_2014,
  file = file.path(folder_path, "PlotList_2014.rds"),
)
```


********************************************************************************

## Conserver les variables d'intérêt

Je pense que la variable PLOT_CODE complétée dans les bases CultIput et CultOutput représente l'identifiant du subplot (plutôt que du plot). C'est pourquoi, je renomme la variable SUB_PLOT_CODE pour ces 2 bases. 


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
ATTENTION : Enlever les n/a des Lab_type, Work_hr, Wage, etc. car cela enlève les lignes indiquant pour une opération spécifique l'utilisation de machine (notamment SP, SD), d'engrais ou de graine. 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


```{r}
CultInput_2014 <- CultInput_2014 |>
  select(-c(UNIT_MAT, QTY_MAT, RATE_MAT, VAL_MAT, SOURCE_MAT, REMARKS)) |>
  filter(!is.na(LAB_TYPE)) |>   # LIGNE A REVOIR
  filter(!is.na(VDS_ID)) |>
  filter(!LAB_TYPE %in% c("0", "8", "B")) |>
  mutate(PLOT_CODE = substr(PLOT_CO, 1, 1)) |>
  rename(SUB_PLOT_CODE = PLOT_CO)

CultOutput_2014 <- CultOutput_2014 |>
  filter(!is.na(VDS_ID)) |>
  select(-c(RENT_VAL, OP_MAIN_PROD_RATE, OP_BY_PROD_UNIT, OP_BY_PROD_QTY, OP_BY_PROD_RATE, OP_OT_PROD_UNIT, OP_OT_PROD_QTY, OP_OT_PROD_RATE, REMARKS)) |>
  rename(SUB_PLOT_CODE = PLOT_CODE)

PlotList_2014 <- PlotList_2014 |>
  filter(!is.na(VDS_ID)) |>
  select(-c(CROP_3, CROP_4, OW_STAT, RENT_REC_PAID, REMARKS, HH_NO))

Landholding_2014 <- Landholding_2014 |>
  mutate(PLOT_CODE = substr(PLOT_CODE, 1, 1)) |>
  select(VDS_ID, PLOT_CODE, SOIL_TYPE, SOIL_TYPE_OT, SOIL_DEPTH, SOIL_FERT, SLOPE, SOIL_DEGR)
```


********************************************************************************

## Harmoniser les variables et supprimer les doublons

### CultInput

```{r Enlever les doublons de CultInput}
# Arrondir WORK_HR à la première décimale (il y a des doublons créés à cause de cela)
CultInput_2014$WORK_HR <- as.numeric(as.character(CultInput_2014$WORK_HR))
CultInput_2014$WORK_HR <- round(CultInput_2014$WORK_HR, 1)
CultInput_2014 <- CultInput_2014 |> 
  filter(!is.na(WORK_HR))

# Arrondir CROP_AREA à la deuxième décimale (pour harmoniser avec les autres bases)
CultInput_2014$CROP_AREA <- as.numeric(as.character(CultInput_2014$CROP_AREA))
CultInput_2014$CROP_AREA <- round(CultInput_2014$CROP_AREA, 2)

# Supprimer les doublons lorsque seule la date SUR_MON_YR diffère (en conservant la date la plus ancienne)
CultInput_2014 <- CultInput_2014 |>
  arrange(SUR_MON_YR) |>
  distinct(across(-SUR_MON_YR), .keep_all = TRUE)
# A CHANGER ? vérifier le nombre de lignes concernées
# Vérifier comment le distinct réagit au n/a
```

On vérifie si les doublons de WORK_HR dans CultInput sont dûs à des salaires différents et pourraient donc représenter des travailleurs distincts. On identifie les doublons pour lesquels les différences entre temps de travail et salaire sont cohérentes. 

```{r Doublons de WORK_HR dans CultInput}
# Tableau des doublons par rapport à WORK_HR et WAGE
dup_rows_CultInput_2014 <- CultInput_2014 |>
  group_by(across(-c(WAGE, WORK_HR))) |>
  filter(n() > 1) |>
  mutate(row_id = row_number()) |> 
  filter(!is.na(WAGE)) |>
  filter(!is.na(WORK_HR)) |>
  ungroup()

# Créer la variable comparison pour vérifier la cohérence de WORK_HR et WAGE entre chaque doublon
dup_rows_CultInput_2014 <- dup_rows_CultInput_2014 |>
  mutate(
    WAGE = as.numeric(WAGE),
    WORK_HR = as.numeric(WORK_HR)
  )

dup_rows_CultInput_2014 <- dup_rows_CultInput_2014 |>
  pivot_wider(
    names_from = row_id,
    values_from = c(WAGE, WORK_HR),
    names_glue = "{.value}_row{row_id}"
  ) |>
  mutate(
    wage_diff = WAGE_row1 - WAGE_row2,
    work_hr_diff = WORK_HR_row1 - WORK_HR_row2,
    comparison = sign(wage_diff) == sign(work_hr_diff) & wage_diff != 0
)

cat("Nombre de doublons avec un salaire et un temps de travail cohérents :", nrow(dup_rows_CultInput_2014 |> filter(comparison)), "\n")
cat("Sur un total de", nrow(dup_rows_CultInput_2014), "doublons soit", round(100 * nrow(dup_rows_CultInput_2014 |> filter(comparison)) / nrow(dup_rows_CultInput_2014), 1), "%\n")
```

```{r Doublons de WORK_HR dans CultInput}
# Supprimer les doublons entre WAGE et WORK_HR quand les salaires et les heures de travail ne sont pas cohérents (en conservant le nombre le plus haut)
dup_rows_CultInput_2014 <- dup_rows_CultInput_2014 |>
  select(VDS_ID, PLOT_NAME, SUB_PLOT_CODE, CROP_AREA, IRRI_AREA, SEASON, DT_OPER, OPERATION, LAB_TYPE, NAME_MAT, TYPE_MAT, comparison)

CultInput_2014 <- CultInput_2014 |>
  left_join(dup_rows_CultInput_2014, by = c("VDS_ID", "PLOT_NAME", "SUB_PLOT_CODE", "CROP_AREA", "IRRI_AREA", "SEASON", "DT_OPER", "OPERATION", "LAB_TYPE", "NAME_MAT", "TYPE_MAT"))

n_avant <- nrow(CultInput_2014)
CultInput_2014 <- CultInput_2014 |>
  filter(is.na(comparison) | comparison) |>
  arrange(desc(WORK_HR)) |>
  select(-comparison)
n_avant - nrow(CultInput_2014)
```

### PlotList 

```{r Enlever les doublons de PlotList}
# Arrondir les variables PLOT_AREA, CROP_AREA et IRRI_AREA à la deuxième décimale (pour harmoniser avec les autres bases)
PlotList_2014$IRRI_AREA <- as.numeric(as.character(PlotList_2014$IRRI_AREA))
PlotList_2014$IRRI_AREA <- round(PlotList_2014$IRRI_AREA, 2)

PlotList_2014$CROP_AREA <- as.numeric(as.character(PlotList_2014$CROP_AREA))
PlotList_2014$CROP_AREA <- round(PlotList_2014$CROP_AREA, 2)

PlotList_2014$PLOT_AREA <- as.numeric(as.character(PlotList_2014$PLOT_AREA))
PlotList_2014$PLOT_AREA <- round(PlotList_2014$PLOT_AREA, 2)

# Supprimer les doublons causés par des valeurs de IRRI_AREA différentes
PlotList_2014 <- PlotList_2014 |>
  arrange(IRRI_AREA) |>
  distinct(across(-IRRI_AREA), .keep_all = TRUE) |>

# Lorsque SUB_PLOT_CODE n'est pas indiqué, je considère l'identifiant du plot (PLOT_CODE)
  mutate(SUB_PLOT_CODE = if_else(is.na(SUB_PLOT_CODE), PLOT_CODE, SUB_PLOT_CODE))
```


```{r}
# Je modifie SUB_PLOT_CODE pour des champs spécifiques, pour lequels SUB_PLOT_CODE et PLOT_CODE sont incohérents. 
PlotList_2014 <- PlotList_2014 |>
  mutate(
    SUB_PLOT_CODE = if_else(
      VDS_ID == "IBH14A0201" & PLOT_CODE == "J" & CROP_AREA == "0.85",
      "J",
      SUB_PLOT_CODE),
    SUB_PLOT_CODE = if_else(
      VDS_ID == "IBH14A0201" & PLOT_CODE == "H" & CROP_AREA == "0.16",
      "H",
      SUB_PLOT_CODE),
    SUB_PLOT_CODE = if_else(
      VDS_ID == "IBH14A0201" & PLOT_CODE == "G" & CROP_AREA == "0.70",
      "G",
      SUB_PLOT_CODE),
    SUB_PLOT_CODE = if_else(
      VDS_ID == "IBH14D0032" & PLOT_CODE == "B" & CROP_AREA == "0.25",
      "B",
      SUB_PLOT_CODE)
  ) 
```


```{r}
# Supprimer les lignes exactement identiques
PlotList_2014 <- PlotList_2014 |> distinct()
CultInput_2014 <- CultInput_2014 |> distinct()
CultOutput_2014 <- CultOutput_2014 |> distinct()
```

Vérifier si des lignes en double ont été créées à cause de variables enlevées. 


### CultOutput

```{r Modifier les variables}
# Pivoter les variables CROP, PRCT_AREA, VAR_NAME, VAR_TYPE, OP_MAIN_PROD_UNIT et OP_MAIN_PROD_QTY en colonnes
CultOutput_2014 <- CultOutput_2014 |>
  group_by(SUR_YEAR, VDS_ID, PLOT_NAME, SUB_PLOT_CODE, SEASON, CROP_AREA, OW_STAT, RENT_FOR) |>
  mutate(crop_id = row_number()) |>
  ungroup() |>
  pivot_wider(
    id_cols = c(VDS_ID, SUB_PLOT_CODE, PLOT_NAME, CROP_AREA, SUR_YEAR, IRRI_AREA, SEASON, RENT_FOR, OW_STAT),
    names_from = crop_id,
    values_from = c(CROP, PRCT_AREA, VAR_NAME, VAR_TYPE, OP_MAIN_PROD_UNIT, OP_MAIN_PROD_QTY),
    names_glue = "{.value}_{crop_id}"
  )
```

```{r Enlever les doublons de CultOutput}
# Tableau des doublons CultOutput
dup_rows_CultOutput_2014 <- CultOutput_2014 |>
  group_by(VDS_ID, SUB_PLOT_CODE, SEASON) |>
  filter(n() > 1) |>
  ungroup()

# Supprimer les lignes avec les mêmes variables VDS_ID / PLOT_CODE / SEASON en double. Supprimer celles avec le plus de NA.
CultOutput_2014 <- CultOutput_2014 |>
  mutate(n_na = rowSums(across(everything(), is.na))) |>
  group_by(VDS_ID, SUB_PLOT_CODE, SEASON) |>
  slice_min(order_by = n_na, with_ties = FALSE) |>
  ungroup() |>
  select(-n_na)
```


### Landholding

```{r Enlever les doublons de Landholding}
# Tableau des doublons Landholding
dup_rows_Landholding <- Landholding_2014 |>
  group_by(VDS_ID, PLOT_CODE) |>
  filter(n() > 1) |>
  ungroup()

# Supprimer les lignes avec les mêmes variables VDS_ID / PLOT_CODE en double. Supprimer celles avec le plus de NA.
Landholding_2014 <- Landholding_2014 |>
  mutate(n_na = rowSums(across(everything(), is.na))) |>
  group_by(VDS_ID, PLOT_CODE) |>
  distinct() |>
  slice_min(order_by = n_na, with_ties = FALSE) |>
  ungroup() |>
  select(-n_na)
```


********************************************************************************

## Vérification des doublons restants

```{r Tableaux de vérification des doublons}
any(duplicated(PlotList_2014[, c("VDS_ID", "SUB_PLOT_CODE", "CROP_1", "CROP_2", "SEASON")]))

# Tableau des doublons PlotList
dup_rows_PlotList_2014 <- PlotList_2014 |>
  group_by(VDS_ID, SUB_PLOT_CODE, SEASON) |>
  filter(n() > 1) |>
  ungroup()

any(duplicated(CultInput_2014[, c("VDS_ID", "SUB_PLOT_CODE", "CROP_AREA", "DT_OPER", "OPERATION", "LAB_TYPE", "SEASON", "NAME_MAT", "TYPE_MAT")]))

any(duplicated(CultOutput_2014[, c("VDS_ID", "SUB_PLOT_CODE", "SEASON")]))
```


********************************************************************************

# Création d'une clé de jonction

## Identification unique des champs

```{r Test PlotList: Différentes cultures selon la saison pour le même champ}
#  Vérifier si un champ (identifié par VDS_ID et SUB_PLOT_CODE) change de culture (CROP_1) selon la SEASON 
champs_avec_cultures_differentes <- PlotList_2014 |>
  filter(CROP_1 != "SEASONAL FALLOW" & !is.na(CROP_1)) |>
  filter(SEASON != "Perennial") |>
  group_by(VDS_ID, PLOT_NAME, PLOT_CODE, SUB_PLOT_CODE, CROP_AREA) |>
  summarise(
    cultures = paste(unique(CROP_1), collapse = ", "),
    nb_cultures = n_distinct(CROP_1),
    .groups = "drop"
  ) |>
  filter(nb_cultures > 1)

# Pour les trois bases, on a besoin de SEASON pour différencier la culture des champs, qui peut changer dans l'année. L'identification des champs est faite par le couple VDS_ID / PLOT_CODE / SEASON.
```

```{r Correspondance VDS_ID}
# Vérifier si les VDS_ID dans CultInput sont présents dans PlotList
all(CultInput_2014$VDS_ID %in% PlotList_2014$VDS_ID)
setdiff(CultInput_2014$VDS_ID, PlotList_2014$VDS_ID)
length(setdiff(unique(CultInput_2014$VDS_ID), unique(PlotList_2014$VDS_ID)))

# Vérifier si les VDS_ID dans CultInput sont présents dans CultOutput
all(CultInput_2014$VDS_ID %in% CultOutput_2014$VDS_ID)
length(setdiff(unique(CultInput_2014$VDS_ID), unique(CultOutput_2014$VDS_ID)))
```

```{r Correspondance des régions}
# Faire ressortir les codes de chaque région puis comparer les bases
CultInput_2014 <- CultInput_2014 |> mutate(STATE = substr(VDS_ID, 2, 3))
PlotList_2014  <- PlotList_2014  |> mutate(STATE = substr(VDS_ID, 2, 3))
CultOutput_2014 <- CultOutput_2014 |> mutate(STATE = substr(VDS_ID, 2, 3))

region_cultinput <- unique(CultInput_2014$STATE)
region_plotlist <- unique(PlotList_2014$STATE)
region_cultoutput <- unique(CultOutput_2014$STATE)

list(
  CultInput = sort(region_cultinput),
  PlotList = sort(region_plotlist),
  CultOutput = sort(region_cultoutput)
)
```

```{r Correspondance des villages}
# Faire ressortir les codes de chaque village puis comparer les bases
CultInput_2014 <- CultInput_2014 |> mutate(VILLAGE = substr(VDS_ID, 2, 6))
PlotList_2014  <- PlotList_2014  |> mutate(VILLAGE = substr(VDS_ID, 2, 6))
CultOutput_2014 <- CultOutput_2014 |> mutate(VILLAGE = substr(VDS_ID, 2, 6))

village_cultinput <- unique(CultInput_2014$VILLAGE)
village_plotlist <- unique(PlotList_2014$VILLAGE)
village_cultoutput <- unique(CultOutput_2014$VILLAGE)

list(
  CultInput = sort(village_cultinput),
  PlotList = sort(village_plotlist),
  CultOutput = sort(village_cultoutput)
)
```

```{r Correspondance PLOT_NAME}
# Vérifier si les PLOT_NAME dans CultInput sont présents dans PlotList
all(CultInput_2014$PLOT_NAME %in% PlotList_2014$PLOT_NAME)
length(setdiff(CultInput_2014$PLOT_NAME, PlotList_2014$PLOT_NAME))

# Vérifier si les PLOT_NAME dans CultInput sont présents dans CultOutput
all(CultInput_2014$PLOT_NAME %in% CultOutput_2014$PLOT_NAME)
length(setdiff(CultInput_2014$PLOT_NAME, CultOutput_2014$PLOT_NAME))

# Nombre de n/a dans PLOT_NAME pour chaque base
sum(is.na(PlotList_2014$PLOT_NAME))
sum(is.na(CultInput_2014$PLOT_NAME))
sum(is.na(CultOutput_2014$PLOT_NAME))
# La variable PLOT_NAME est largement incomplète dans CultInput.  
```


********************************************************************************

## Correspondance des ID dans chaque base

```{r Correspondance CultInput -> PlotList}
# Vérifier les couples (VDS_ID, SUB_PLOT_CODE, SEASON)
cultinput_keys <- CultInput_2014 |>
  select(VDS_ID, SUB_PLOT_CODE, SEASON) |>
  distinct()

plotlist_keys <- PlotList_2014 |>
  select(VDS_ID, SUB_PLOT_CODE, SEASON) |>
  distinct()

# Identifier les champs de CultInput non trouvés dans PlotList
non_match <- anti_join(cultinput_keys, plotlist_keys, by = c("VDS_ID", "SEASON", "SUB_PLOT_CODE"))

n_non_matched <- nrow(non_match)
n_total <- nrow(cultinput_keys)
prop_non_matched <- round(n_non_matched / n_total * 100, 2)

cat(" - Plots totaux dans CultInput :", n_total, "\n")
cat(" - Plots sans équivalent dans PlotList :", n_non_matched, "\n")
cat(" - Proportion sans équivalent :", prop_non_matched, "%\n")
```

```{r Correspondance CultInput -> CultOutput}
# Vérifier les couples (VDS_ID, PLOT_CODE, SEASON)
cultoutput_keys <- CultOutput_2014 |>
  select(VDS_ID, SUB_PLOT_CODE, SEASON) |>
  distinct()

# Identifier les champs de CultInput non trouvés dans CultOutput
non_match2 <- anti_join(cultinput_keys, cultoutput_keys, by = c("VDS_ID", "SUB_PLOT_CODE", "SEASON"))

n_non_matched2 <- nrow(non_match2)
prop_non_matched2 <- round(n_non_matched2 / n_total * 100, 2)

cat(" - Plots totaux dans CultInput :", n_total, "\n")
cat(" - Plots sans équivalent dans CultOutput :", n_non_matched2, "\n")
cat(" - Proportion sans équivalent :", prop_non_matched2, "%\n")
```

```{r Correspondance CultInput -> Landholding}
# Vérifier les couples (VDS_ID, PLOT_CODE)
landholding_keys <- Landholding_2014 |>
  select(VDS_ID, PLOT_CODE)

cultinput_plots_keys <- CultInput_2014 |>
  select(VDS_ID, PLOT_CODE) |>
  distinct()

# Identifier les lignes dans CultiInput qui n'ont pas de match dans Landholding
non_match3 <- anti_join(cultinput_plots_keys, landholding_keys, by = c("VDS_ID", "PLOT_CODE"))

n_non_matched3 <- nrow(non_match)
n_total3 <- nrow(cultinput_plots_keys)
prop_non_matched3 <- round(n_non_matched / n_total3 * 100, 2)

cat(" - Total de plots dans CultInput :", n_total3, "\n")
cat(" - Plots sans match avec Landholding :", n_non_matched3, "\n")
cat(" - Proportion sans match :", prop_non_matched3, "%\n")
```


********************************************************************************

# Création d'une base de vérification des champs

## Base validation_ID

```{r Correspondance couple VDS_ID / SUB_PLOT_CODE / SEASON entre les bases, message=FALSE, warning=FALSE}
cultinput_keys <- CultInput_2014 |>
  select(VDS_ID, SUB_PLOT_CODE, PLOT_NAME, CROP_AREA, SEASON) |>
  distinct()

plotlist_keys <- PlotList_2014 |>
  select(VDS_ID, PLOT_CODE, SUB_PLOT_CODE, PLOT_NAME, CROP_AREA, SEASON, CROP_1, CROP_2) |>
  distinct()

cultoutput_keys <- CultOutput_2014 |>
  select(VDS_ID, SUB_PLOT_CODE, PLOT_NAME, CROP_AREA, SEASON, CROP_1, CROP_2) |>
  distinct() |>
  rename(
    PLOT_NAME_CO = PLOT_NAME,
    CROP_AREA_CO = CROP_AREA,
    CROP_1_CO = CROP_1,
    CROP_2_CO = CROP_2
  )

validation_ID <- cultinput_keys |>
  rename(
    PLOT_NAME_CI = PLOT_NAME,
    CROP_AREA_CI = CROP_AREA,
  ) |>
  left_join(
    plotlist_keys |> rename(
      PLOT_NAME_PL = PLOT_NAME,
      CROP_AREA_PL = CROP_AREA,
      CROP_1_PL = CROP_1,
      CROP_2_PL = CROP_2,
    ),
    by = c("VDS_ID", "SUB_PLOT_CODE", "SEASON")
  ) |>
  left_join(cultoutput_keys, by = c("VDS_ID", "SUB_PLOT_CODE", "SEASON"))
```


## Modifier Base validation_ID

```{r Harmoniser: Méthode fonction}
# Harmoniser la base validation_ID: quand 2 des 3 sources (_CI, _CO, _PL) sont identiques pour une même variable, remplacer la 3e valeur par cette valeur majoritaire.
harmonise_ID <- function(df, var) {
  var_CI <- sym(paste0(var, "_CI"))
  var_CO <- sym(paste0(var, "_CO"))
  var_PL <- sym(paste0(var, "_PL"))

  df <- df |>
    mutate(
      "{var}_CI" := as.character(!!var_CI),
      "{var}_CO" := as.character(!!var_CO),
      "{var}_PL" := as.character(!!var_PL)
    ) %>%
    mutate(
      !!var_CI := case_when(
        !is.na(!!var_CO) & !is.na(!!var_PL) & !!var_CO == !!var_PL ~ !!var_CO,
        TRUE ~ !!var_CI
      ),
      !!var_CO := case_when(
        !is.na(!!var_CI) & !is.na(!!var_PL) & !!var_CI == !!var_PL ~ !!var_CI,
        TRUE ~ !!var_CO
      ),
      !!var_PL := case_when(
        !is.na(!!var_CI) & !is.na(!!var_CO) & !!var_CI == !!var_CO ~ !!var_CI,
        TRUE ~ !!var_PL
      )
    )

  return(df)
}

validation_ID <- harmonise_ID(validation_ID, "CROP_AREA")
validation_ID <- harmonise_ID(validation_ID, "PLOT_NAME")
```

```{r Résultats Base validation_ID}
validation_ID <- validation_ID |>
  mutate(
    PLOT_NAME_match = PLOT_NAME_CI == PLOT_NAME_PL & PLOT_NAME_CI == PLOT_NAME_CO,
    CROP_AREA_match = CROP_AREA_CI == CROP_AREA_PL & CROP_AREA_CI == CROP_AREA_CO
  )

validation_ID_false <- validation_ID |>
  filter(!PLOT_NAME_match | !CROP_AREA_match)

n_validation_ID <- nrow(validation_ID)
area_match <- nrow(validation_ID |> filter(CROP_AREA_match))
two_match <- nrow(validation_ID |> filter(CROP_AREA_match & PLOT_NAME_match))
one_match <- nrow(validation_ID |> filter(CROP_AREA_match | PLOT_NAME_match))
one_na <- nrow(validation_ID |> filter((is.na(CROP_AREA_match) | !CROP_AREA_match) &
                      (is.na(PLOT_NAME_match) | !PLOT_NAME_match)))
one_false <- nrow(validation_ID |> filter(!CROP_AREA_match | !PLOT_NAME_match))

cat("Total des champs identifiés dans CultInput :", n_validation_ID, "\n")
cat(" - 2 matchs :", two_match, "\n")
cat(" - Au moins 1 match :", one_match, "\n", "dont AREA :", area_match, "\n")
cat(" - Aucun match (soit NA soit False) :", one_na, "\n")
cat(" - Au moins 1 False :", one_false, "\n")
```

## Identifier les champs validés

Je crée la variable OK pour identifier et sélectionner seulement les champs ayant au moins un match (validation du champ par CROP_AREA et/ou PLOT_NAME).

```{r}
# Création de la variable OK
validation_ID <- validation_ID |>
  mutate(
    OK = coalesce(PLOT_NAME_match, FALSE) | 
      coalesce(CROP_AREA_match, FALSE)
  )

nb_OK <- sum(validation_ID$OK, na.rm = TRUE)
nb_total <- nrow(validation_ID)
pourcentage_OK <- round((nb_OK / nb_total) * 100, 1)

cat("Nombre de lignes validées : ", nb_OK, "\n")
cat("Pourcentage du total : ", pourcentage_OK, "%\n")
```

```{r}
# Ajouter la variable OK dans toutes les bases 

# CultInput: 
CultInput_2014 <- CultInput_2014 |>
  left_join(
    validation_ID |> select(VDS_ID, SUB_PLOT_CODE, SEASON, OK),
    by = c("VDS_ID", "SUB_PLOT_CODE", "SEASON")
  )

# CultOutput
CultOutput_2014 <- CultOutput_2014 |>
  left_join(
    validation_ID |> select(VDS_ID, SUB_PLOT_CODE, SEASON, OK),
    by = c("VDS_ID", "SUB_PLOT_CODE", "SEASON")
  )

# PlotList
PlotList_2014 <- PlotList_2014 |>
  left_join(
    validation_ID |> select(VDS_ID, SUB_PLOT_CODE, SEASON, OK), 
    by = c("VDS_ID", "SUB_PLOT_CODE", "SEASON")
  )

nb_cultinput_OK <- sum(CultInput_2014$OK, na.rm = TRUE)
nb_cultinput_total <- nrow(CultInput_2014)
pourcentage_cultinput_OK <- round((nb_cultinput_OK / nb_cultinput_total) * 100, 1)

nb_cultoutput_OK <- sum(CultOutput_2014$OK, na.rm = TRUE)
nb_cultoutput_total <- nrow(CultOutput_2014)
pourcentage_cultoutput_OK <- round((nb_cultoutput_OK / nb_cultoutput_total) * 100, 1)

nb_plotlist_OK <- sum(PlotList_2014$OK, na.rm = TRUE)
nb_plotlist_total <- nrow(PlotList_2014)
pourcentage_plotlist_OK <- round((nb_plotlist_OK / nb_plotlist_total) * 100, 1)

lignes_validees <- tibble(
  Base = c("CultInput", "CultOutput", "PlotList"),
  `Nombre de lignes validées` = c(nb_cultinput_OK, nb_cultoutput_OK, nb_plotlist_OK),
  `Total de lignes` = c(nb_cultinput_total, nb_cultoutput_total, nb_plotlist_total),
  `Pourcentage validé (%)` = c(pourcentage_cultinput_OK, pourcentage_cultoutput_OK, pourcentage_plotlist_OK)
)

print(lignes_validees)
```

```{r}
# Sélectionner dans toutes les bases seulement les lignes validées
CultInput_2014 <- CultInput_2014 |>
  filter(OK==TRUE) |>
  select(-OK)

CultOutput_2014 <- CultOutput_2014 |>
  filter(OK==TRUE) |>
  select(-OK)

PlotList_2014 <- PlotList_2014 |>
  filter(OK==TRUE)
```


********************************************************************************

# Harmonisation des données

## ID des cultures

```{r}
# Créer une liste avec toutes les valeurs uniques de CROP pour associer un numéro à chaque culture

# Table de correspondance des cultures
correspondances <- tribble(
  ~CULTURE_VARIANT,      ~CULTURE_STANDARD,
  "BAMBOO TREE",         "BAMBOO",
  "BLACKGRAM",           "BLACK GRAM",
  "GREEN GRAM",          "BLACK GRAM",
  "MAIZE FODDER",        "MAIZE",
  "GREENGRAM",           "GREEN GRAM",
  "CHICK PEA",           "CHICKPEA",
  "CHIKPEA",             "CHICKPEA",
  "FELLOW",              "SEASONAL FALLOW",
  "FALLOW",              "SEASONAL FALLOW",
  "GROUND NUT",          "GROUNDNUT",
  "HORSE GRAM",          "HORSEGRAM",
  "TURMARIC",            "TURMURIC",
  "MANGO TREE",          "MANGO",
  "MANGOES",             "MANGO",
  "MANGOES TREE",        "MANGO",
  "MUSTERD",             "MUSTARD",
  "MUSTURD",             "MUSTARD",
  "MASTURD",             "MUSTARD",
  "PAADY",               "PADDY",
  "PADDY  SEEDLING",     "PADDY",
  "PADDY GODA",          "PADDY",
  "PADDY NURSURY",       "PADDY",
  "PADDY SEED",          "PADDY",
  "PADDY SEEDLING",      "PADDY",
  "PADDY(SEEDLING)",     "PADDY",
  "PIGION PEA",          "PIGEONPEA",
  "POTATAO",             "POTATO",
  "SORGHUM FODDER",      "SORGHUM",
  "LIN SEED",            "LINSEED",
  "FODDER (EGYPTIAN CLOVER)","EGYPTIAN CLOVER",
  "BERSEEM",             "EGYPTIAN CLOVER",
  "OATS (JAI)",          "JAI",
  "FODDER OATS (JAI)",   "JAI",
  "GREEN FODDER JAI",    "JAI",
  "GREEN FODDER (JANER)","GREEN FODDER",
  "PADDY LOCAL",         "PADDY",
  "PADY",                "PADDY",
  "SMALL MILLET (MARUA)","MARUA",
  "FRENCH BEANS",        "BEANS",
  "FREANCH BEANS",       "BEANS",
  "SMALL MILLET (SARGUJA)","SARGUJA",
  "CHILLIES GREEN",      "CHILLIES",
  "CHILLI GREEN",        "CHILLIES",
  "GREEN CHILLY",        "CHILLIES",
  "PEA",                 "PEAS",
  "SESBANIA ACULEATA (DHAICHA)","DHAICHA",
  "LADYSFINGER",         "LADYS FINGER",
  "LEAFY VEGETABLE",     "LEAFY",
  "CORIENDER",           "CORIANDER",
  "RIDGEGOURD",          "RIDGE GOURD",
  "WHEET",               "WHEAT"
)
```

```{r}
# PlotList :
plotlist_allcult <- PlotList_2014 |>
    semi_join(
    CultInput_2014 |> select(VDS_ID, SEASON, SUB_PLOT_CODE),
    by = c("VDS_ID", "SUB_PLOT_CODE", "SEASON")
  ) |>
  select(CROP_1, CROP_2) |>
  pivot_longer(everything(), names_to = "CROP_COL", values_to = "CULTURE_VARIANT") |> 
  filter(!is.na(CULTURE_VARIANT)) |>
  mutate(CULTURE_VARIANT = trimws(CULTURE_VARIANT)) |>
  left_join(correspondances, by = c("CULTURE_VARIANT")) |> 
  mutate(CULTURE_FINAL = coalesce(CULTURE_STANDARD, CULTURE_VARIANT)) |> 
  select(CULTURE_VARIANT, CULTURE_FINAL) |>
  distinct()

# CultOuput : 
cultoutput_allcult <- CultOutput_2014 |>
  semi_join(
    CultInput_2014 |> select(VDS_ID, SEASON, SUB_PLOT_CODE),
    by = c("VDS_ID", "SUB_PLOT_CODE", "SEASON")
  ) |>
  select(CROP_1, CROP_2, CROP_3, CROP_4) |> 
  mutate(across(c(CROP_1, CROP_2, CROP_3, CROP_4), toupper)) |> 
  pivot_longer(everything(), names_to = "CROP_COL", values_to = "CULTURE_VARIANT") |> 
  filter(!is.na(CULTURE_VARIANT)) |>
  mutate(CULTURE_VARIANT = trimws(CULTURE_VARIANT)) |>
  left_join(correspondances, by = c("CULTURE_VARIANT")) |> 
  mutate(CULTURE_FINAL = coalesce(CULTURE_STANDARD, CULTURE_VARIANT)) |> 
  select(CULTURE_FINAL, CULTURE_VARIANT) |>
  distinct()

all_cultures <- bind_rows(plotlist_allcult, cultoutput_allcult) |>
  filter(CULTURE_FINAL != "ANNUAL")

crop_ids <- all_cultures |>
  distinct(CULTURE_FINAL) |>
  arrange(CULTURE_FINAL) |>
  mutate(CROP_ID = sprintf("C%02d", row_number()))

all_cultures <- all_cultures |>
  left_join(crop_ids, by = "CULTURE_FINAL") 
```

```{r, message=FALSE, warning=FALSE}
# Ajouter CROP_ID dans PlotList
PlotList_2014 <- PlotList_2014 |> 
  mutate(across(c(CROP_1, CROP_2), ~ trimws(.))) |>
  rename(CULTURE_VARIANT_1 = CROP_1, CULTURE_VARIANT_2 = CROP_2) |>
  left_join(all_cultures |> select(CULTURE_VARIANT, CULTURE_FINAL, CROP_ID) |> rename(CULTURE_VARIANT_1 = CULTURE_VARIANT, CROP_1 = CULTURE_FINAL, CROP_1_ID = CROP_ID),
            by = "CULTURE_VARIANT_1") |>
  left_join(all_cultures |> select(CULTURE_VARIANT, CULTURE_FINAL, CROP_ID) |> rename(CULTURE_VARIANT_2 = CULTURE_VARIANT, CROP_2 = CULTURE_FINAL, CROP_2_ID = CROP_ID),
            by = "CULTURE_VARIANT_2") |>
  select(-CULTURE_VARIANT_1, -CULTURE_VARIANT_2)

#Pour CultOutput
CultOutput_2014 <- CultOutput_2014 |>
  mutate(across(c(CROP_1, CROP_2, CROP_3, CROP_4), ~ trimws(toupper(.)))) |>
  rename(CULTURE_VARIANT_1 = CROP_1, CULTURE_VARIANT_2 = CROP_2, CULTURE_VARIANT_3 = CROP_3, CULTURE_VARIANT_4 = CROP_4) |>
  left_join(all_cultures |> select(CULTURE_VARIANT, CULTURE_FINAL, CROP_ID) |> rename(CULTURE_VARIANT_1 = CULTURE_VARIANT, CROP_1 = CULTURE_FINAL, CROP_1_ID = CROP_ID),
            by = "CULTURE_VARIANT_1") |>
  left_join(all_cultures |> select(CULTURE_VARIANT, CULTURE_FINAL, CROP_ID) |> rename(CULTURE_VARIANT_2 = CULTURE_VARIANT, CROP_2 = CULTURE_FINAL, CROP_2_ID = CROP_ID),
            by = "CULTURE_VARIANT_2") |>
  left_join(all_cultures |> select(CULTURE_VARIANT, CULTURE_FINAL, CROP_ID) |> rename(CULTURE_VARIANT_3 = CULTURE_VARIANT, CROP_3 = CULTURE_FINAL, CROP_3_ID = CROP_ID),
            by = "CULTURE_VARIANT_3") |>
  left_join(all_cultures |> select(CULTURE_VARIANT, CULTURE_FINAL, CROP_ID) |> rename(CULTURE_VARIANT_4 = CULTURE_VARIANT, CROP_4 = CULTURE_FINAL, CROP_4_ID = CROP_ID),
            by = "CULTURE_VARIANT_4")
```


********************************************************************************

# Création d'une base commune

## Supprimer les doublons avant de joindre toutes les bases

```{r}
# Supprimer les lignes exactement identiques
PlotList_2014 <- PlotList_2014 |> distinct()
CultInput_2014 <- CultInput_2014 |> distinct()
CultOutput_2014 <- CultOutput_2014 |> distinct()
```

```{r}
# Je modifie la variable OK en FALSE pour un plot identifé, dont les variables d'identification sont en double et qui ont le même nombre de NA. 
PlotList_2014 <- PlotList_2014 |>
  mutate(
    OK = if_else(
      VDS_ID == "IBH14D0032" & PLOT_NAME == "KOLAI BADH" & SUB_PLOT_CODE == "C" & SEASON == "Kharif" & CROP_AREA == "0.25",
      FALSE,
      OK
    )
  ) 

# Dans PlotList, je supprime les champs en double (même VDS_ID, PLOT_CODE, SUB_PLOT_CODE et SEASON) en gardant la ligne avec le moins de NA.
PlotList_2014 <- PlotList_2014 |>
  mutate(n_na = rowSums(across(everything(), is.na))) |>
  group_by(VDS_ID, PLOT_CODE, SUB_PLOT_CODE, SEASON) |>
  slice_min(order_by = n_na, with_ties = FALSE) |>
  ungroup() |>
  select(-n_na)
```

```{r}
# Vérifier les doublons restants
any(duplicated(PlotList_2014[, c("VDS_ID", "SUB_PLOT_CODE", "SEASON")]))

any(duplicated(CultInput_2014[, c("VDS_ID", "SUB_PLOT_CODE", "CROP_AREA", "DT_OPER", "OPERATION", "LAB_TYPE", "SEASON")]))

any(duplicated(CultOutput_2014[, c("VDS_ID", "SUB_PLOT_CODE", "SEASON")]))
```

```{r}
na_irri_cultinput <- CultInput_2014 |>
  group_by(VDS_ID, SUB_PLOT_CODE, SEASON) |>
  summarise(na_irri_cultinput = sum(is.na(IRRI_AREA)), .groups = "drop")

na_irri_plotlist <- PlotList_2014 |>
  group_by(VDS_ID, SUB_PLOT_CODE, SEASON) |>
  summarise(na_irri_plotlist = sum(is.na(IRRI_AREA)), .groups = "drop")

cat("Nombre de champs sans information sur l'irrigation dans CultInput : \n")
cat("- dans CultInput :", nrow(na_irri_cultinput), "\n")
cat("- dans PlotList :", nrow(na_irri_plotlist), "\n")
```
Il y a plus de champs qui ont indiqué l'irrigation dans CultInput, je vais garder la variable Irrigation de CultInput pour la base finale. 


## Joindre en colonne les bases

```{r}
Cultivation_2014 <- CultInput_2014 |>
  select(-SUR_YR, -PLOT_NAME) |>

# D'abord joindre avec CultOutput
  left_join(
    CultOutput_2014 |> select(VDS_ID, SUB_PLOT_CODE, SEASON, OP_MAIN_PROD_UNIT_1, OP_MAIN_PROD_UNIT_2, OP_MAIN_PROD_UNIT_3, OP_MAIN_PROD_QTY_1, OP_MAIN_PROD_QTY_2, OP_MAIN_PROD_QTY_3, CROP_1, CROP_2, CROP_3, CROP_4, CROP_1_ID, CROP_2_ID, CROP_3_ID, CROP_4_ID, PRCT_AREA_1, PRCT_AREA_2, PRCT_AREA_3, PRCT_AREA_4,VAR_NAME_1, VAR_NAME_2, VAR_NAME_3, VAR_NAME_4, VAR_TYPE_1, VAR_TYPE_2, VAR_TYPE_3, VAR_TYPE_4),
    by = c("VDS_ID", "SUB_PLOT_CODE", "SEASON")
  ) |>
  
# Puis joindre avec Landholding 
  left_join(Landholding_2014, by = c("VDS_ID", "PLOT_CODE")) |>
  select(-PLOT_CODE) |>  
  # Enlever PLOT_CODE créé manuellement pour conserver celui indiqué dans PlotList
  
# Enfin joindre avec PlotList
  left_join(
    PlotList_2014 |> select(
      VDS_ID, PLOT_CODE, SUB_PLOT_CODE, PLOT_AREA, SEASON, SUR_YR,
      CROP_1_PL = CROP_1,
      CROP_2_PL = CROP_2,
      CROP_1_ID_PL = CROP_1_ID,
      CROP_2_ID_PL = CROP_2_ID
    ),
    by = c("VDS_ID", "SUB_PLOT_CODE", "SEASON")
  ) |>

# Remplacer les NA avec les infos de PlotList
  mutate(
    CROP_1 = coalesce(CROP_1, CROP_1_PL),
    CROP_2 = coalesce(CROP_2, CROP_2_PL),
    CROP_1_ID = coalesce(CROP_1_ID, CROP_1_ID_PL),
    CROP_2_ID = coalesce(CROP_2_ID, CROP_2_ID_PL)
  ) |>
  select(-CROP_1_PL, -CROP_2_PL, -CROP_1_ID_PL, -CROP_2_ID_PL)
```

```{r}
# Changer l'ordre des colonnes de Cultivation_2014
Cultivation_2014 <- Cultivation_2014 |>
  relocate(SUR_YR, .before = VDS_ID) |>
  relocate(PLOT_CODE, .before = SUB_PLOT_CODE) |>
  relocate(PLOT_AREA, .before = CROP_AREA) |>
  relocate(SUR_MON_YR, .after = SUR_YR) |>
  relocate(IRRI_AREA, .after = CROP_AREA) |>
  relocate(c(CROP_1_ID, CROP_2_ID, CROP_3_ID, CROP_4_ID), 
           .after = c(CROP_1, CROP_2, CROP_3, CROP_4)) |>
  relocate(c(VAR_TYPE_1, VAR_TYPE_2, VAR_TYPE_3, VAR_TYPE_4), 
           .after = c(VAR_NAME_1, VAR_NAME_2, VAR_NAME_3, VAR_NAME_4)) |>
  relocate(TYPE_MAT, .after = NAME_MAT)
```


********************************************************************************

# Nettoyer le base créée

## Corriger les superficies

*Gérer les n/a pour Plot_area*

Lorsque la superficie du plot est manquante (Plot_area = n/a), je considère alors la superficie du subplot (Crop_area) si elle est indiquée. 

```{r}
na_plot_area <- Cultivation_2014 |>
  distinct(VDS_ID, PLOT_CODE, SUB_PLOT_CODE, PLOT_AREA, CROP_AREA) |>
  filter(is.na(PLOT_AREA)) |>
  nrow()

cat("Nombre de champs sans Plot_area : ", na_plot_area, "\n")

Cultivation_2014 <- Cultivation_2014 |>
  mutate(PLOT_AREA = if_else(is.na(PLOT_AREA), CROP_AREA, PLOT_AREA))
```

*Corriger les incohérences entre Plot_area et Crop_area*

Pour certains ménages, la superficie du subplot dépasse celle du plot, ce qui n'est pas cohérent. Dans ces cas, je remplace la taille du subplot par celle du plot. 

```{r}
nb_modifications <- Cultivation_2014 |>
  distinct(VDS_ID, PLOT_CODE, SUB_PLOT_CODE, PLOT_AREA, CROP_AREA) |>
  filter(!is.na(CROP_AREA), !is.na(PLOT_AREA), CROP_AREA > PLOT_AREA) |>
  nrow()

cat("Nombre de champs modifiés : ", nb_modifications, "\n")
```

```{r}
# Remplacer CROP_AREA par PLOT_AREA quand CROP_AREA > PLOT_AREA
Cultivation_2014 <- Cultivation_2014 |>
  mutate(
    CROP_AREA = if_else(
      CROP_AREA > PLOT_AREA,
      PLOT_AREA,
      CROP_AREA,
      missing = CROP_AREA
    )
  )
```


## Harmoniser Prct_area

```{r}
# Harmoniser la variable PRCT_AREA_1
Cultivation_2014 <- Cultivation_2014 |>
  mutate(
    across(starts_with("PRCT_AREA"), as.numeric, .names = "{.col}")) |>
  mutate(
    PRCT_AREA_1 = if_else(
      (is.na(PRCT_AREA_2)) & (is.na(PRCT_AREA_3)) & (is.na(PRCT_AREA_4)),
      100,
      PRCT_AREA_1
    ) 
  ) |>
  mutate(
    across(starts_with("PRCT_"), ~ if_else(is.na(.), 0, .), .names = "{.col}")
  )
```

```{r}
# Compter le nombre de lignes pour lesquelles la somme des PRCT_AREA n'est pas égale à 100
Cultivation_2014 <- Cultivation_2014 |>
  mutate(
    PRCT_SUM = rowSums(across(starts_with("PRCT_AREA")), na.rm = TRUE)
  )

# Modifier PRCT_AREA_1 tel que la somme des PRCT soit égale à 100
Cultivation_2014 <- Cultivation_2014 |>
  mutate(
    PRCT_AREA_1 = if_else(
      PRCT_SUM != 100,
      50,
      PRCT_AREA_1
    ),
    PRCT_AREA_2 = if_else(
      PRCT_SUM != 100,
      50,
      PRCT_AREA_2
    )
  ) |>
  select(-PRCT_SUM)
```

```{r}
# Enlever ANNUAL de la variable CROP
Cultivation_2014 <- Cultivation_2014 |>
  mutate(CROP_2 = if_else(CROP_2 == "ANNUAL", NA_character_, CROP_2))
```


## Harmoniser les opérations

Avant d'harmoniser les opérations, je crée la variable Fertilizer qui indique si l'opération a nécessité de l'engrais.

```{r}
# Variable FERTILIZER
Cultivation_2014 <- Cultivation_2014 |>
  mutate(FERTILIZER = str_detect(OPERATION, "FERTILIZ|FERTIGATION"))
```

```{r}
# Harmoniser la variable OPERATION
Cultivation_2014 <- Cultivation_2014 |>
  mutate(OPERATION = toupper(OPERATION))
```

```{r}
# Tableau de correspodance des opérations pour les regouper en catégories simplifiées
correspondances_oper <- tribble(
  ~OPERATION_VARIANT,                             ~OPERATION,
  
  # LAND PREPARATION(PLOUGHING)
  "BEEDING",                                      "LAND PREPARATION",
  "BED PREPARATION",                              "LAND PREPARATION",
  "BED PREPRATION",                               "LAND PREPARATION",
  "LAND PREPARATION-BED PREPARATION",             "LAND PREPARATION",
  "LAND PREPARATION-BED&FURROW PREPARATION",      "LAND PREPARATION",
  "LAND PREPARATION-BED&FERROW PREPARATION",      "LAND PREPARATION",
  "LAND PREPARATION-BED&FURROW PREPARAT",         "LAND PREPARATION",
  "LAND PREPARATION",                             "LAND PREPARATION",
  "EARTHING UP",                                  "LAND PREPARATION",
  "EARTHING UP WITH FERTILIZER",                  "LAND PREPARATION",
  "LAND PREPARATION-EARTHING UP",                 "LAND PREPARATION",
  "HARROWING",                                    "LAND PREPARATION",
  "LAND PREPARATION-SOIL SPREADING",              "LAND PREPARATION",
  "SOIL SPREADING",                               "LAND PREPARATION",
  "PLOUGHING",                                    "LAND PREPARATION",
  "PLOUHGING",                                    "LAND PREPARATION",
  "PLOUGING",                                     "LAND PREPARATION",
  "MUD PLOUGHING",                                "LAND PREPARATION",
  "HOE PLOUGHING",                                "LAND PREPARATION",
  "MB PLOUGHING",                                 "LAND PREPARATION",
  "DOUBLE PLOUGHING",                             "LAND PREPARATION",
  "PLOUGHING WITH FERTILIZER",                    "LAND PREPARATION",
  "PLOUGHING AND SEED SOWING",                    "LAND PREPARATION",
  "PLOUGHING AND SEED SOWING WITH FERTILIZER",    "LAND PREPARATION",
  "PLOUGHING/HARROWING",                          "LAND PREPARATION",
  "PLOUGHING BY HOE",                             "LAND PREPARATION",
  "LAND PREPARATION-PUDDLING",                    "LAND PREPARATION",
  "LAND PREPARATION -PUDDLING",                   "LAND PREPARATION",
  "PUDDLING",                                     "LAND PREPARATION",
  "LAND PREPARATION - PUDDLING",                  "LAND PREPARATION",
  "PANJI",                                        "LAND PREPARATION",
  "LAND PREPARATION-PATTA",                       "LAND PREPARATION",
  "LAND PREPARATION-PLOUGHING",                   "LAND PREPARATION",
  "LAND PREPARATION- PLOUGHING",                  "LAND PREPARATION",
  "LAND PREPARATION - PLOUHGING",                 "LAND PREPARATION",
  "LAND PREPARATION - PLOUGHING",                 "LAND PREPARATION",
  "LAND PREPARATION/PLOUGHING",                   "LAND PREPARATION",
  "LAND PREPARATION -PLOUGHING",                  "LAND PREPARATION",
  "LAND PREPARATION-DOUBLE PLOUGHING",            "LAND PREPARATION",
  "LAND PREPARATION-MB PLOUGHING",                "LAND PREPARATION",
  "LAND PREPARATION-PATTA PASS",                  "LAND PREPARATION",
  "LAND PREPARATION-PATTA PAS",                   "LAND PREPARATION",
  "LAND PREPARATION-PATTA",                       "LAND PREPARATION",
  "LAND PREPARATION-PATTAPASS",                   "LAND PREPARATION",
  "LAND PREPARATION HARROWING",                   "LAND PREPARATION",
  "LAND PREPARATION-HARROWING",                   "LAND PREPARATION",
  "LAND PREPARATIONG-HARROWING",                  "LAND PREPARATION",
  "LAND PREPARATION - HARROWING",                 "LAND PREPARATION",
  "LAND PREPARATION-ROTOVATOR",                   "LAND PREPARATION",
  "LAND PREPARATION-WITH ROTOVATOR",              "LAND PREPARATION",
  "HARROWING",                                    "LAND PREPARATION",
  "LAND PREPARATION-BROAD CASTING",               "LAND PREPARATION",
  "LAND PREPARATION-PANJI",                       "LAND PREPARATION",
  "LAND PREPARATION-PUNJI",                       "LAND PREPARATION",
  "LAND PREPARATION-PHANTAN",                     "LAND PREPARATION",
  "LAND PREPARATION-V-PASS",                      "LAND PREPARATION",
  "LAND PREPARATION-PHANTAN",                     "LAND PREPARATION",
  "LAND PREPARATION-V-PASS",                      "LAND PREPARATION",
  "MAKING RIDGES & FURROWS",                      "LAND PREPARATION",
  "LAND PREPARATION-RIDGES AND FURROWS",          "LAND PREPARATION",
  "LAND PREPARATION-RIDGES & FURROWS",            "LAND PREPARATION",
  "LAND PREPARATION-MAKING RIDGES & FURROWS",     "LAND PREPARATION",
  "LAND PREPARATION-ROTAVATOR",                   "LAND PREPARATION",
  
  # UPROOTING
  "UPROOTING JASMINE",                            "UPROOTING",
  "LAND PREPARATION-UPROOTING",                   "UPROOTING",
  "LAND PREPARATION-UPROOTING BETEL VINE",        "UPROOTING",
  
  # INTERCULTURE
  "INTERCULTURE",                                 "INTERCULTURE",
  "INTERCULTURE/HOEING",                          "INTERCULTURE",
  "INTERCULTURE WITH FERTILIZER",                 "INTERCULTURE",
  "INTERCULTURE WITH EARTHING UP",                "INTERCULTURE",
  "INTERCULTURE/HOEING-SORGHUM",                  "INTERCULTURE",
  
  # FIELD CLEANING
  "LAND PREPARATION-FIELD CLEANING",              "FIELD CLEANING",
  "FIELD CLEANING",                               "FIELD CLEANING",
  
  # FENCE TRMMING
  "FENCE TRIMMING",                               "FENCE TRIMMING",
  "FENCING",                                      "FENCE TRIMMING",
  
  # TRANSPLANTING
  "PLANTING",                                     "TRANSPLANTING",
  "TRANSPLANTING",                                "TRANSPLANTING",
  "TRANSPLANTING WITH FERTILIZER",                "TRANSPLANTING",
  "TRANSPLANTING-ONION",                          "TRANSPLANTING",
  "TRANSPLANTING-SUGARCANE",                      "TRANSPLANTING",
  "TRANSPLANTING AND PLOUGHING",                  "TRANSPLANTING",
  "PLANTATION",                                   "TRANSPLANTING",
  
  # NURSERY RAISING
  "NURSERY RAISING",                              "NURSERY RAISING",
  
  # PESTICIDE
  "PESTICIDE SPAYING",                            "PESTICIDE",
  "PESTICIDE",                                    "PESTICIDE",
  "SPRAYING",                                     "PESTICIDE",
  "PESTISIDESPRAY",                               "PESTICIDE",
  
  # SOWING
  "SEED SOWING",                                  "SOWING",
  "SOWING/SOWING WITH FERTILIZER",                "SOWING",
  "SEED APPLICATION",                             "SOWING",
  "RESOWING",                                     "SOWING",
  "RESOWING WITH FERTILIZER",                     "SOWING",
  "SEED TREATMENT",                               "SOWING",
  "POTATO SOWING",                                "SOWING",
  "SOWING/SOWING WITH FERTILIZER-MAIZE",          "SOWING",
  "SOWING/SOWING WITH FERTILIZER-SORGHUM",        "SOWING",
  "SOWING/SOWING WITH FERTILIZER-SOYBEAN",        "SOWING",
  "LAND PREPARATION AND SEED SOWING",             "SOWING",
  "LAND PREPARATION AND SOWING",                  "SOWING",
  
  # HERBICIDE
  "WEEDICIDE",                                    "HERBICIDE",
  "HARBISIDE APPLICATION",                        "HERBICIDE",
  "HERBICIDE",                                    "HERBICIDE",
  "WEEDICIDE APPLICATION-PIGEONPEA",              "HERBICIDE",
  "WEEDICIDE SPRAYING",                           "HERBICIDE",
  "WEEDYSIDE SPRAY",                              "HERBICIDE",
  "DEFOLIATION",                                  "HERBICIDE",
  "WEEDICIDE APPLICATION",                        "HERBICIDE",
  "IPM & IDM TECHNOLOGIES",                       "HERBICIDE",
  
  # PLANT PROTECTION
  "PLANT PROTECTION",                             "PLANT PROTECTION",
  "PLANT PROTECTION-SOYBEAN",                     "PLANT PROTECTION",
  "PLANT PROTECTION-PIGEONEPA",                   "PLANT PROTECTION",
  "PLANT PROTECTION-PIGEONPEA",                   "PLANT PROTECTION",
  "BAGGING",                                      "PLANT PROTECTION",
  
  # HAND WEEDING
  "WEEDING",                                      "HAND WEEDING",
  "HAND WEEDING",                                 "HAND WEEDING",
  "HAND WEEDING-PIGEONPEA",                       "HAND WEEDING",
  "HAND WEEDING & THINNING",                      "HAND WEEDING",
  
  # THINNING
  "THINNING",                                     "THINNING",
  "BEDICIDE",                                     "THINNING",
  
  # FERTILIZER
  "FERTILIZER APPLICATION",                       "FERTILIZER",
  "FERTILIZER APPLICATION-PIGEONPEA",             "FERTILIZER",
  "FERTIGATION",                                  "FERTILIZER",
  "FYM/COMPOST APPLICATION",                      "FERTILIZER",
  "MICRONUTRIENT",                                "FERTILIZER",
  "MICRONUTRIENT APPLICATION",                    "FERTILIZER",
  "NUTRIENT",                                     "FERTILIZER",
  "TILIZER APPLICATION",                          "FERTILIZER",
  "APPLYING FERTILIZER",                          "FERTILIZER",
  
  # HARVESTING
  "HARVESTING",                                   "HARVESTING",
  "HARVESTING-SOYBEAN",                           "HARVESTING",
  "HARVESTING-PIGEONPEA",                         "HARVESTING",
  "HARVESTING-COTTON",                            "HARVESTING",
  "HARVESTING-SORGHUM",                           "HARVESTING",
  "HARVESTING-ONION",                             "HARVESTING",
  "HARVESTING-GROUNDNUT",                         "HARVESTING",
  "HARVESTING-ARECANUT",                          "HARVESTING",
  "HARVESTING-CHRYSANTHEMUM",                     "HARVESTING",
  "HARVESTING-BETEL VINE",                        "HARVESTING",
  "HARVESTING-BLACKGRAM",                         "HARVESTING",
  "HARVESTING-BY-PRODUCT",                        "HARVESTING",
  "HARVESTING BY-PRODUCT",                        "HARVESTING",
  "HARVESTING BY-PRODUCT-SORGHUM",                "HARVESTING",
  "HARVESTING-D LAB LAB",                         "HARVESTING",
  "HARVESTING-COCONUT",                           "HARVESTING",
  "HARVESTING-SUGARCANE",                         "HARVESTING",
  "HARVESTING-CHICKPEA",                          "HARVESTING",
  "HARVESTING-COWPEA",                            "HARVESTING",
  "HARVESTING-SORGHUM FODDER",                    "HARVESTING",
  "HARVESTING-HORSEGRAM",                         "HARVESTING",
  "HARVESTING-HULGA",                             "HARVESTING",
  "HARVESTING-MAIZE",                             "HARVESTING",
  "HARVESTING-MAIZE FODDER",                      "HARVESTING",
  "HARVESTING-MATKI",                             "HARVESTING",
  "HARVESTING-FINGER MILLET",                     "HARVESTING",
  "HERVESTING",                                   "HARVESTING",
  
  # THRESHING
  "THRESHING",                                    "THRESHING",
  "THRESHING-ARECANUT",                           "THRESHING",
  "THRESHING-BLACKGRAM",                          "THRESHING",
  "THRESHING-CHICKPEA",                           "THRESHING",
  "THRESHING-COWPEA",                             "THRESHING",
  "THRESHING-D LAB LAB",                          "THRESHING",
  "THRESHING-FINGER MILLET",                      "THRESHING",
  "THRESHING-GROUNDNUT",                          "THRESHING",
  "THRESHING-HORSEGRAM",                          "THRESHING",
  "THRESHING-HULGA",                              "THRESHING",
  "THRESHING-MAIZE",                              "THRESHING",
  "THRESHING-MATKI",                              "THRESHING",
  "THRESHING-PIGEONPEA",                          "THRESHING",
  "THRESHING-SORGHUM",                            "THRESHING",
  "THRESHING-SOYBEAN",                            "THRESHING",
  "THRESHING & TRANSPORT",                        "THRESHING",
  "THRESHING AND TRANSPORT",                      "THRESHING",
  
  # HARVESTING/THRESHING
  "THRESHING HARVESTING",                         "HARVESTING/THRESHING",
  "THRASHING HARVESTING",                         "HARVESTING/THRESHING",
  "HARVESTING AND THRESHING",                     "HARVESTING/THRESHING",
  "HARVESTING & THRESHING",                       "HARVESTING/THRESHING",
  "HARVESTING & THRESHING-SOYBEAN",               "HARVESTING/THRESHING",
  
  # WINNOWING
  "WINNOWING",                                    "WINNOWING",
  
  # TRANSPORT
  "TRANSPORT",                                    "TRANSPORT",
  "TRANSPORT-COTTON",                             "TRANSPORT",
  "TRANSPORT-PIGEONPEA",                          "TRANSPORT",
  "TRANSPORT-SORGHUM",                            "TRANSPORT",
  "TRANSPORT-SOYBEAN",                            "TRANSPORT",
  
  # IRRIGATION
  "IRRIGATION",                                   "IRRIGATION",
  "IRRIGATION-PIGEONPEA",                         "IRRIGATION",
  "IRRIGATION MANUAL",                            "IRRIGATION",
  
  # FUMIGATION
  "FUMIGATION",                                   "FUMIGATION",
  
  # ABELING
  "ABELING",                                      "ABELING",
  
  # LEVELING
  "LEVELING",                                     "LEVELING",
  "LAND PREPARATION-LEVELLING",                   "LEVELING",
  "LAND PREPARATION-HARROWING & LEVELLING",       "LEVELING",
  "PLOUGING WITH LEVELING",                       "LEVELING",
  "PLOUGHING WITH LEVELING",                      "LEVELING",
  "PLOUHGING WITH LEVELING",                      "LEVELING",
  
  # DIGGING
  "LAND PREPARATION-DIGGING",                     "DIGGING",
  "GAP FILLING/THINNING",                         "DIGGING",
  "SOIL DIGGING",                                 "DIGGING",
  "MAKING LINES",                                 "DIGGING",
  "DIGGING OF PIT",                               "DIGGING",
  "LAND PREPARATION-SOIL DIGGING",                "DIGGING",
  "LAND PREPARATION-ROUND DIGGING",               "DIGGING",
  "TRENCHING",                                    "DIGGING",
  
  # DIPPING
  "DIPPING",                                      "DIPPING",
  "DRENCHING",                                    "DIGGING",
  
  # BUNDING
  "BUNDING",                                      "BUNDING",
  "BUND MAKING",                                  "BUNDING",
  "BUND TRIMMING",                                "BUNDING",
  "BUND REPAIR",                                  "BUNDING",
  "FARM BUNDING",                                 "BUNDING",
  "WATER CHANNEL",                                "BUNDING",
  "LAND PREPARATION-WATER CHANNEL",               "BUNDING",
  "LAND PREPARATION-MAKING BASIN",                "BUNDING",
  "LAND PREPARATION-BUND REPAIR",                 "BUNDING",
  "LAND PREPARATION-BUND MAKING",                 "BUNDING",
  "LAND PREPARATION-BUND CLEANING",               "BUNDING",
  "LAND PREPARATION-RING BASIN PREPARATION",      "BUNDING",
  "LAND PREPARATION-FARM BUNDING",                "BUNDING",
  
  # BY PRODUCT MAKING
  "BY PRODUCT MAKING",                            "BY PRODUCT MAKING",
  
  # SUPERVISION
  "WATCHING",                                     "SUPERVISION",
  "SUPERVISION",                                  "SUPERVISION",
  
  # PINCHING/CUTTING
  "PRUNING",                                      "PINCHING/CUTTING",
  "PINCHING",                                     "PINCHING/CUTTING",
  "CUTTING",                                      "PINCHING/CUTTING",
  "NIPPING",                                      "PINCHING/CUTTING",
  "PRUNING/PINCHING",                             "PINCHING/CUTTING",
  "AIR LAYERING",                                 "PINCHING/CUTTING",
  
  # MULCHING
  "MULCHING",                                     "MULCHING",
  "MANURING",                                     "MULCHING",
  
  # POD COLLECTION
  "POD COLLECTION",                               "POD COLLECTION",
  
  # GRADING/TAGGING
  "GRADING",                                      "GRADING/TAGGING",
  "TAGGING",                                      "GRADING/TAGGING",
  
  # LOADING
  "LOADING",                                      "LOADING",
  "STACKING",                                     "LOADING",
  "PACKING OF RAISINS",                           "LOADING",
  
  # CURING
  "CURING",                                       "CURING",
  
  # TRANSFORMATION
  "PROCESSING OF ARECANUT",                       "TRANSFORMATION",
  "PROCESSING OF ARACANUT",                       "TRANSFORMATION",
  "REMOVING RAISINS FROM RAISIN SHED",            "TRANSFORMATION",
  "CLEANING OF RAISIN SHED",                      "TRANSFORMATION",
  "PACKING OF RAISINS",                           "TRANSFORMATION",
  
  # GIRDLING
  "GIRDLING",                                     "GIRDLING",
  "GRIDLING",                                     "GIRDLING"
)
```

```{r, message=FALSE, warning=FALSE}
# Créer un ID des opérations
correspondances_oper <- correspondances_oper |>
  arrange(OPERATION, OPERATION_VARIANT) |>
  mutate(OPER_ID = sprintf("C%02d", row_number()))

# Ajouter OPERATION_ID dans Cultivation_2014
Cultivation_2014 <- Cultivation_2014 |>
  rename(OPERATION_VARIANT = OPERATION) |>
  left_join(correspondances_oper |> select(OPERATION_VARIANT, OPERATION, OPER_ID),
          by = "OPERATION_VARIANT")
```

```{r}
# Diviser les opérations qui regroupent plusieurs catégories en deux variables

# Tableau de correspondances des opérations regoupant plusieurs catégories
operation_divisees <- tribble(
~OPERATION_VARIANT,                       ~OPER_1,           ~OPER_2,
"LAND PREPARATION-HARROWING & LEVELLING", "LAND PREPARATION","LEVELING",
"PLOUGING WITH LEVELING",                 "LAND PREPARATION","LEVELING",
"PLOUGHING WITH LEVELING",                "LAND PREPARATION","LEVELING",
"PLOUHGING WITH LEVELING",                "LAND PREPARATION","LEVELING",
"LAND PREPARATION-HARROWING & LEVELLING", "LAND PREPARATION","LEVELING",
"LAND PREPARATION-FIELD CLEANING",        "LAND PREPARATION", "FIELD CLEANING",
"LAND PREPARATION-BUND CLEANING",         "LAND PREPARATION", "BUNDING",
"LAND PREPARATION-BUND MAKING",           "LAND PREPARATION", "BUNDING",
"LAND PREPARATION-BUND REPAIR",           "LAND PREPARATION", "BUNDING",
"LAND PREPARATION-RING BASIN PREPARATION","LAND PREPARATION", "BUNDING",
"LAND PREPARATION-WATER CHANNEL",         "LAND PREPARATION", "BUNDING",
"LAND PREPARATION-FARM BUNDING",          "LAND PREPARATION", "BUNDING",
"LAND PREPARATION-DIGGING",               "LAND PREPARATION", "DIGGING",
"LAND PREPARATION-SOIL DIGGING",          "LAND PREPARATION", "SOIL DIGGING",
"LAND PREPARATION-ROUND DIGGING",         "LAND PREPARATION", "DIGGING",
"LAND PREPARATION-UPROOTING",             "LAND PREPARATION", "UPROOTING",
"LAND PREPARATION-UPROOTING BETEL VINE",  "LAND PREPARATION", "UPROOTING",
"THRASHING HARVESTING",                   "HARVESTING",       "THRESHING",
"THRESHING HARVESTING",                   "HARVESTING",       "THRESHING",
"THRESHING-HARVESTING",                   "HARVESTING",       "THRESHING",
"HAND WEEDING & THINNING",                "HAND WEEDING",     "THINNING",
"HARVESTING AND THRESHING",               "HARVESTING",       "THRESHING",
"HARVESTING & THRESHING-SOYBEAN",         "HARVESTING",       "THRESHING",
"INTERCULTURE WITH EARTHING UP",          "INTERCULTURE",     "EARTHING UP",
"GAP FILLING/THINNING",                   "GAP FILLING",      "THINNING",
"TRANSPLANTING AND PLOUGHING",            "TRANSPLANTING",    "PLOUGHING",
"THRESHING & TRANSPORT",                  "THRESHING",        "TRANSPORT",
"THRESHING AND TRANSPORT",                "THRESHING",        "TRANSPORT",
"PLOUGHING AND SEED SOWING",                "LAND PREPARATION","SOWING",
"PLOUGHING AND SEED SOWING WITH FERTILIZER","LAND PREPARATION","SOWING"
)
```

```{r, warning=FALSE}
# Ajouter le tableau de correspondance des opérations divisées dans Cultivation_2014
Cultivation_2014 <- Cultivation_2014 |>
  left_join(operation_divisees, by = c("OPERATION_VARIANT"))

cat("Nombre de lignes ayant plusieurs opérations  :", sum(!is.na(Cultivation_2014$OPER_2)), "\n")
cat("Pourcentage du total :", sum(!is.na(Cultivation_2014$OPER_2))/sum(is.na(Cultivation_2014$OPER_2)), "%")
```

Comme les lignes regroupant plusieurs opérations représentent une partie minime de la base, je considère ces lignes dans la variable OPERATION. 


## Créations de variables

### Salaire horaire

```{r}
Cultivation_2014$WAGE <- as.numeric(as.character(Cultivation_2014$WAGE))
Cultivation_2014$WAGE <- round(Cultivation_2014$WAGE, 0)

Cultivation_2014 <- Cultivation_2014 |>
  mutate(WAGE_PER_HR = WAGE / WORK_HR)
Cultivation_2014$WAGE_PER_HR <- round(Cultivation_2014$WAGE_PER_HR, 2) 
```


```{r}
# Supprimer les variables non utilisées
Cultivation_2014 <- Cultivation_2014 |>
  select(-OPER_1, -OPER_2, -OPERATION_VARIANT) |>

# Modifier l'ordre des variables 
  relocate(OPERATION, .after = DT_OPER) |>
  relocate(c(OPER_ID, FERTILIZER), .after = OPERATION) |>
  relocate(WAGE_PER_HR, .after = WAGE) |>
  relocate(c(SOIL_TYPE, SOIL_TYPE_OT, SOIL_DEPTH, SOIL_FERT, SLOPE, SOIL_DEGR), .after = VILLAGE)
```


### Nombre de ménages et champs distincts

```{r}
n_households <- Cultivation_2014 |>
  distinct(VDS_ID) |>
  summarise(n_households = n()) |>
  pull(n_households)

n_champs <- Cultivation_2014 |>
  distinct(VDS_ID, SUB_PLOT_CODE) |>
  summarise(n_champs = n()) |>
  pull(n_champs)

cat(" Nombre de ménages dans Cultivation_2014 :", n_households, "\n")
cat(" Nombre de champs (toutes saisons confondues) :", n_champs, "\n")
```

********************************************************************************

# Liens extérieurs

## Enregistrer Cultivation_2014

```{r}
# Définir le chemin du dossier
folder_path <- here("Base de données générées", "Cultivation_2014")

# Créer le dossier s'il n'existe pas
if (!dir.exists(folder_path)) {
  dir.create(folder_path, recursive = TRUE)
}

# Enregistrer le fichier CSV
write.csv(
  Cultivation_2014,
  file = file.path(folder_path, "Cultivation_2014.csv"),
  row.names = FALSE
)

# Enregistrer le fichier RDS
saveRDS(
  Cultivation_2014,
  file = file.path(folder_path, "Cultivation_2014.rds"),
)
```

