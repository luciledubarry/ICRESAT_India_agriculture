---
title: "Régression (partie 1) : Analyse du travail total par acre selon la caste"
format: html
editor: source
---

```{r, message=FALSE, warning=FALSE}
rm(list = ls())
graphics.off()
cat("\014")
```

```{r, message=FALSE, warning=FALSE}
here::i_am("ICRESAT_database_analysis/Analyse_caste.qmd")
library(dplyr)
library(tidyr)
library(readxl)
library(ggplot2)
library(scales)
library(knitr)
library(tibble)
library(tidyverse)
library(gt)
```

```{r}
Cultivation_expand <- readRDS(here::here("Base de données générées", "Cultivation_expand", "Cultivation_expand.rds"))
```


L'objectif de ces premières régressions est de comprendre pourquoi on observe un différence de l'intensité du travail (Hr/acre) entre les castes, même après avoir contrôler pour plusieurs variables (mécanisation, superficie du champ). 

Niveau d'analyse : On se concentre au niveau des opérations par champ. 
p = plot ; H = Household ; o = opération. 

Outcome : Travail total par acre, tout type de travail confondu. 


********************************************************************************

## Préparer la base

### Gérer les doublons dans Cultivation_expand

```{r}
# Vérifier qu'il n'y ait pas de champs en double (pour le riz en Kharif)
dup_plots_paddy <- Cultivation_expand |>
  filter(SEASON == "KHARIF") |>
  select(VDS_ID, PLOT_CODE, SEASON, CROP, AREA_CROP, VAR_TYPE, VAR_NAME, REGION, STATE, VILLAGE, CASTE_GROUP, CASTE, IRRI_CROP, IRRIGATION, CROP_ID, MULTI_CROPING, OP_MAIN_PROD_QTY, OP_MAIN_PROD_UNIT) |>
  distinct() |>
  group_by(VDS_ID, PLOT_CODE, AREA_CROP) |>
  filter(n() > 1) |>
  mutate(row_in_group = row_number()) |> 
  ungroup()
```

Il y a des champs en double à cause de OP_MAIN_PROD_QTY et OP_MAIN_PROD_UNIT. Une fois ces variables enlevées, il faut distinct la table.  

```{r}
# CODE A REVOIR: Supprimer les doublons causés par OP
test_cultivation_expand <- Cultivation_expand |>
  group_by(across(-c(OP_MAIN_PROD_UNIT, OP_MAIN_PROD_QTY))) |>
  summarise(
    OP_MAIN_PROD_QTY = first(na.omit(OP_MAIN_PROD_QTY), default = NA),
    OP_MAIN_PROD_UNIT = first(na.omit(OP_MAIN_PROD_UNIT), default = NA),
    .groups = "drop"
  ) |>
  distinct()

test_cultivation_expand |>
  group_by(across(-c(OP_MAIN_PROD_UNIT, OP_MAIN_PROD_QTY))) |>
  filter(n() > 1)
```

```{r}
# Supprimer les doublons causés par OP
Cultivation_expand <- Cultivation_expand |>
  select(-c(OP_MAIN_PROD_QTY, OP_MAIN_PROD_UNIT)) |>
  distinct()
```


### Modifier les variables

*Sélectionner les variables*

```{r}
# Filtrer pour la culture du riz en Kharif
Cultivation_paddy <- Cultivation_expand |>
  filter(SEASON == "KHARIF", CROP == "PADDY") |>

# Sélectionner les variables d'intérêt
  select(VDS_ID, CASTE_GROUP, PLOT_CODE, AREA_CROP, OPERATION, LAB_TYPE, WORK_HR, IRRIGATION, MACHINERY, VAR_TYPE, REGION, STATE, VILLAGE) |>
  distinct()   # Enlever les lignes identiques créées lors de la sélection des variables
```

```{r}
# Vérifier les doublons restants après avoir sélectionné les variables
Cultivation_paddy |>
  group_by(VDS_ID, PLOT_CODE, AREA_CROP) |>
  filter(n_distinct(IRRIGATION) > 1 |
         n_distinct(VAR_TYPE) > 1 |
         n_distinct(CASTE_GROUP) > 1 |
         n_distinct(STATE) > 1 |
         n_distinct(VILLAGE) > 1) |>
  mutate(row_in_group = row_number()) |>
  ungroup()
```

*Modifier Machinery*

Je modifie la variable Machinery telle que pour chaque champ, une opération est considérée mécanisée si au moins un outil a été utilisé pour cette opération, à n'importe quel moment de la saison. 

Rappel: La variable Machinery indique 'mécanisé' si l'opération a nécessité un outil (TR, SP, DS, SM, PT, ET, CH, TH, SD, MK, DP) ou si la variable TYPE_MAT indique 'Machinery' (concerne également AUTO et CYCLE WEEDER).

```{r}
# Identifier les champs ayant utilisé des outils pendant la saison pour chaque opération
Cultivation_paddy <- Cultivation_paddy |>
  group_by(VDS_ID, PLOT_CODE, AREA_CROP, OPERATION) |>
  mutate(MACHINERY = replace_na(MACHINERY, "Non mécanisé"),
         MACHINERY = any(MACHINERY == "Mécanisé")
         ) |>
  ungroup()
```

Ensuite, j'identifie les champs dont le labour est mécanisé. 

```{r}
# Identifier les champs mécanisant land preparation 
mechanized_tilling <- Cultivation_paddy |>
  filter(OPERATION == "LAND PREPARATION") |>
  group_by(VDS_ID, PLOT_CODE, AREA_CROP) |>
  reframe(mechanized_tilling = any(MACHINERY == TRUE))

# Ajouter la variable à Cultivation_paddy
Cultivation_paddy <- Cultivation_paddy |>
  left_join(mechanized_tilling, by = c("VDS_ID", "PLOT_CODE", "AREA_CROP"))
```


*Réécrire les variables en dummies*

```{r}
Cultivation_paddy <- Cultivation_paddy |>
  mutate(
    MACHINERY = if_else(MACHINERY, "1", "0"),
    mechanized_tilling = if_else(mechanized_tilling, "1", "0"),
    IRRIGATION = recode(IRRIGATION, `Irrigué` = "1", `Non irrigué` = "0"),
    REGION = recode(REGION, `EAST` = "1", `SAT` = "0")
    )
```

Je définie les catégories de référence pour STATE et VILLAGE.

```{r}
# State
Cultivation_paddy$STATE <- factor(Cultivation_paddy$STATE)
Cultivation_paddy$STATE <- relevel(Cultivation_paddy$STATE, ref = "AP")

# Village
Cultivation_paddy$VILLAGE <- factor(Cultivation_paddy$VILLAGE)
Cultivation_paddy$VILLAGE <- relevel(Cultivation_paddy$VILLAGE, ref = "AP14C")

# Caste
Cultivation_paddy$CASTE_GROUP <- factor(Cultivation_paddy$CASTE_GROUP)
Cultivation_paddy$CASTE_GROUP <- relevel(Cultivation_paddy$CASTE_GROUP, ref = "BC")
```

La fonction lm() crée automatiquement des dummies (n - 1), avec la modalité omise étant la catégorie de référence. 



### Variables créées

*Heures de travail par acre par champ*

```{r}
# Additionner les heures de travail par champ
Cultivation_paddy <- Cultivation_paddy |>
  filter(AREA_CROP != 0) |>  # Enlever les champs dont la superficie est nulle
  group_by(across(-c("WORK_HR", "LAB_TYPE"))) |>
  summarise(OPER_HRS = sum(WORK_HR, na.rm = TRUE), .groups = "drop") |>

# Diviser les heures totales par acre
  mutate(HACRE_OPER = OPER_HRS/AREA_CROP)
```


*Sommer les champs d'un même ménage*

Je calcule la superficie totale de tous les champs d'un même ménage, pour toutes les cultures (dont le riz) en Kharif. Pour cela, je reviens sur la base Cultivation_expand. 

```{r}
household_plots <- Cultivation_expand |>
  filter(SEASON == "KHARIF", CROP != "SEASONAL FALLOW") |>
  distinct(VDS_ID, PLOT_CODE, AREA_CROP) |>
  group_by(VDS_ID) |>
  summarise(AREA_HH = sum(AREA_CROP), .groups = "drop")

Cultivation_paddy <- Cultivation_paddy |>
  left_join(household_plots, by = "VDS_ID")
```


*Superficie au carré*

```{r}
Cultivation_paddy <- Cultivation_paddy |>
  mutate(AREA_CROP_SQ = AREA_CROP^2,
         AREA_HH_SQ = AREA_HH^2)
```



********************************************************************************

## Régression

### Toutes opérations

```{r}
reg_all <- lm(HACRE_OPER ~ CASTE_GROUP + AREA_CROP + AREA_CROP_SQ + AREA_HH + AREA_HH_SQ + IRRIGATION + MACHINERY + mechanized_tilling  + STATE, data = Cultivation_paddy)
summary(reg_all)
```

Attention : On ne peut pas mettre à la fois STATE et VILLAGE dans la régression. 
Il y a un problème de colinéarité parfaite entre STATE et VILLAGE, car chaque village appartient exactement à un seul state. Donc connaître le village suffit à déterminer le state et inversement. 

Code pour Var_type : 
- 1 = Local (catégorie de référence),
- 2 = HYV,
- 3 = Hybrid,
- 4 = BT,
- 5 = Others


### Par opération

Je refais la régression pour les opérations principales du riz en Kharif. 

```{r}
reg_land <- Cultivation_paddy |>
  filter(OPERATION == "LAND PREPARATION") |>
  lm(formula = HACRE_OPER ~ CASTE_GROUP + AREA_CROP + AREA_CROP_SQ + AREA_HH + AREA_HH_SQ + IRRIGATION + MACHINERY + mechanized_tilling  + STATE,
     data = _)
summary(reg_land)
```

Attention : Pour cette régression, c'est normal que mechanized_tilling soit NA, car machinery_tilling et MACHINERY sont identiques. R ne considère pas le deuxième coefficient, à cause du problème de colinéarité que cela causerait. 


```{r}
reg_harvest <- Cultivation_paddy |>
  filter(OPERATION == "HARVESTING & THRESHING") |>
  lm(formula = HACRE_OPER ~ CASTE_GROUP + AREA_CROP + AREA_CROP_SQ + AREA_HH + AREA_HH_SQ + IRRIGATION + MACHINERY + mechanized_tilling  + STATE,
     data = _)
summary(reg_harvest)
```


```{r}
reg_weeding <- Cultivation_paddy |>
  filter(OPERATION == "HAND WEEDING") |>
  lm(formula = HACRE_OPER ~ CASTE_GROUP + AREA_CROP + AREA_CROP_SQ + AREA_HH + AREA_HH_SQ + IRRIGATION + mechanized_tilling + STATE,
     data = _)
summary(reg_weeding)
```

Attention: Il faut enlever Machinery pour étudier Hand weeding, car cette opération n'est jamais mécanisé. Il n'y a qu'une seule modalité pour Machinery, donc R ne peut pas créer de dummies. 


```{r}
reg_trans <- Cultivation_paddy |>
  filter(OPERATION == "TRANSPLANTING") |>
  lm(formula = HACRE_OPER ~ CASTE_GROUP + AREA_CROP + AREA_CROP_SQ + AREA_HH + AREA_HH_SQ + IRRIGATION + MACHINERY + mechanized_tilling + STATE,
     data = _)
summary(reg_trans)

```





