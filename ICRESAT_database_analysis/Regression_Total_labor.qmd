---
title: "Régression (partie 1) : Analyse du travail total par acre selon la caste"
format: html
editor: source
---

```{r, message=FALSE, warning=FALSE}
rm(list = ls())
graphics.off()
cat("\014")
```

```{r, message=FALSE, warning=FALSE}
here::i_am("ICRESAT_database_analysis/Analyse_caste.qmd")
library(dplyr)
library(tidyr)
library(readxl)
library(ggplot2)
library(scales)
library(knitr)
library(tibble)
library(tidyverse)
library(gt)
```

```{r}
Cultivation_expand <- readRDS(here::here("Base de données générées", "Cultivation_expand", "Cultivation_expand.rds"))
```


********************************************************************************

## Préparer la base

### Gérer les doublons dans Cultivation_expand

```{r}
# Vérifier qu'il n'y ait pas de champs en double (pour le riz en Kharif)
dup_plots_paddy <- Cultivation_expand |>
  filter(SEASON == "KHARIF") |>
  select(VDS_ID, PLOT_CODE, SEASON, CROP, AREA_CROP, VAR_TYPE, VAR_NAME, REGION, STATE, VILLAGE, CASTE_GROUP, CASTE, IRRI_CROP, IRRIGATION, CROP_ID, MULTI_CROPING, OP_MAIN_PROD_QTY, OP_MAIN_PROD_UNIT) |>
  distinct() |>
  group_by(VDS_ID, PLOT_CODE, AREA_CROP) |>
  filter(n() > 1) |>
  mutate(row_in_group = row_number()) |> 
  ungroup()
```

Il y a des champs en double à cause de OP_MAIN_PROD_QTY et OP_MAIN_PROD_UNIT. Une fois ces variables enlevées, il faut distinct la table.  

```{r}
# CODE A REVOIR: Supprimer les doublons causés par OP
test_cultivation_expand <- Cultivation_expand |>
  group_by(across(-c(OP_MAIN_PROD_UNIT, OP_MAIN_PROD_QTY))) |>
  summarise(
    OP_MAIN_PROD_QTY = first(na.omit(OP_MAIN_PROD_QTY), default = NA),
    OP_MAIN_PROD_UNIT = first(na.omit(OP_MAIN_PROD_UNIT), default = NA),
    .groups = "drop"
  ) |>
  distinct()

test_cultivation_expand |>
  group_by(across(-c(OP_MAIN_PROD_UNIT, OP_MAIN_PROD_QTY))) |>
  filter(n() > 1)
```

```{r}
# Supprimer les doublons causés par OP
Cultivation_expand <- Cultivation_expand |>
  select(-c(OP_MAIN_PROD_QTY, OP_MAIN_PROD_UNIT)) |>
  distinct()
```


### Modifier les variables

*Sélectionner les variables*

```{r}
# Filtrer pour la culture du riz en Kharif
Cultivation_paddy <- Cultivation_expand |>
  filter(SEASON == "KHARIF", CROP == "PADDY") |>

# Sélectionner les variables d'intérêt
  select(VDS_ID, CASTE_GROUP, PLOT_CODE, AREA_CROP, OPERATION, LAB_TYPE, WORK_HR, IRRIGATION, MACHINERY, VAR_TYPE, REGION, STATE, VILLAGE) |>
  distinct()   # Enlever les lignes identiques créées lors de la sélection des variables
```

```{r}
# Vérifier les doublons restants après avoir sélectionné les variables
Cultivation_paddy |>
  group_by(VDS_ID, PLOT_CODE, AREA_CROP) |>
  filter(n_distinct(IRRIGATION) > 1 |
         n_distinct(VAR_TYPE) > 1 |
         n_distinct(CASTE_GROUP) > 1 |
         n_distinct(STATE) > 1 |
         n_distinct(VILLAGE) > 1) |>
  mutate(row_in_group = row_number()) |>
  ungroup()
```

*Modifier Machinery*

Je modifie la variable Machinery telle que pour chaque champ, une opération est considérée mécanisée si au moins un outil a été utilisé pour cette opération, à n'importe quel moment de la saison. 

Rappel: La variable Machinery indique 'mécanisé' si l'opération a nécessité un outil (TR, SP, DS, SM, PT, ET, CH, TH, SD, MK, DP) ou si la variable TYPE_MAT indique 'Machinery' (concerne également AUTO et CYCLE WEEDER).

```{r}
# Identifier les champs ayant utilisé des outils pendant la saison pour chaque opération
Cultivation_paddy <- Cultivation_paddy |>
  group_by(VDS_ID, PLOT_CODE, AREA_CROP, OPERATION) |>
  mutate(MACHINERY = any(MACHINERY == "Mécanisé")) |>
  ungroup()
```

Si on souhaite considérer les opérations sans heure de travail (Machinery = n/a) comme non mécanisée : ajouter MACHINERY = replace_na(MACHINERY, "Non mécanisé"), sachant que cela change le sens du coefficient pour le régression. 

Ensuite, j'identifie les champs dont le labour est mécanisé. 

```{r}
# Identifier les champs mécanisant land preparation 
mechanized_tilling <- Cultivation_paddy |>
  filter(OPERATION == "LAND PREPARATION") |>
  group_by(VDS_ID, PLOT_CODE, AREA_CROP) |>
  reframe(mechanized_tilling = any(MACHINERY == TRUE))

# Ajouter la variable à Cultivation_paddy
Cultivation_paddy <- Cultivation_paddy |>
  left_join(mechanized_tilling, by = c("VDS_ID", "PLOT_CODE", "AREA_CROP"))
```


*Réécrire les variables en dummies*

```{r}
Cultivation_paddy <- Cultivation_paddy |>
  mutate(
    mechanized_tilling = if_else(mechanized_tilling, "1", "0"),
    IRRIGATION = recode(IRRIGATION, `Irrigué` = "1", `Non irrigué` = "0"),
    REGION = recode(REGION, `EAST` = "1", `SAT` = "0")
    )
```

Si on considère les n/a de Machinery comme "Non mécanisé", on peut ajouter : MACHINERY = if_else(MACHINERY, "1", "0"),

Je définie les catégories de référence pour STATE et VILLAGE.

```{r}
# State
Cultivation_paddy$STATE <- factor(Cultivation_paddy$STATE)
Cultivation_paddy$STATE <- relevel(Cultivation_paddy$STATE, ref = "AP")

# Village
Cultivation_paddy$VILLAGE <- factor(Cultivation_paddy$VILLAGE)
Cultivation_paddy$VILLAGE <- relevel(Cultivation_paddy$VILLAGE, ref = "AP14C")

# Caste
Cultivation_paddy$CASTE_GROUP <- factor(Cultivation_paddy$CASTE_GROUP)
Cultivation_paddy$CASTE_GROUP <- relevel(Cultivation_paddy$CASTE_GROUP, ref = "BC")
```

La fonction lm() crée automatiquement des dummies (n - 1), avec la modalité omise étant la catégorie de référence. 



### Variables créées

*Sommer les champs d'un même ménage*

Je calcule la superficie totale de tous les champs d'un même ménage, pour toutes les cultures (dont le riz) en Kharif. Pour cela, je reviens sur la base Cultivation_expand. 

```{r}
household_plots <- Cultivation_expand |>
  filter(SEASON == "KHARIF", CROP != "SEASONAL FALLOW") |>
  distinct(VDS_ID, PLOT_CODE, AREA_CROP) |>
  group_by(VDS_ID) |>
  summarise(AREA_HH = sum(AREA_CROP), .groups = "drop")

Cultivation_paddy <- Cultivation_paddy |>
  left_join(household_plots, by = "VDS_ID")
```


*Superficie au carré*

```{r}
Cultivation_paddy <- Cultivation_paddy |>
  mutate(AREA_CROP_SQ = AREA_CROP^2,
         AREA_HH_SQ = AREA_HH^2)
```


*Heures de travail par acre par champ*

```{r}
# Additionner les heures de travail par champ
Cultivation_all <- Cultivation_paddy |>
  filter(AREA_CROP != 0) |>  # Enlever les champs dont la superficie est nulle
  group_by(across(-c("WORK_HR", "LAB_TYPE"))) |>
  summarise(OPER_HRS = sum(WORK_HR, na.rm = TRUE), .groups = "drop") |>

# Diviser les heures totales par acre
  mutate(HACRE_OPER = OPER_HRS/AREA_CROP)
```


********************************************************************************

## Régressions

## Tout type de travail confondu

L'objectif de ces premières régressions est de comprendre pourquoi on observe un différence de l'intensité du travail (Hr/acre) entre les castes, même après avoir contrôler pour plusieurs variables (mécanisation, superficie du champ). 

Niveau d'analyse : On se concentre au niveau des opérations par champ. 
p = plot ; H = Household ; o = opération. 

Outcome : Travail total par acre, tout type de travail confondu. 


### Toutes opérations

```{r}
reg_all <- lm(HACRE_OPER ~ CASTE_GROUP + AREA_CROP + AREA_CROP_SQ + AREA_HH + AREA_HH_SQ + IRRIGATION + MACHINERY + mechanized_tilling  + STATE, data = Cultivation_all)
summary(reg_all)
```

Attention : Il y a beaucoup d'observations effacées à cause des n/a de Machinery. 

Attention : On ne peut pas mettre à la fois STATE et VILLAGE dans la régression. 
Il y a un problème de colinéarité parfaite entre STATE et VILLAGE, car chaque village appartient exactement à un seul state. Donc connaître le village suffit à déterminer le state et inversement. 

Code pour Var_type : 
- 1 = Local (catégorie de référence),
- 2 = HYV,
- 3 = Hybrid,
- 4 = BT,
- 5 = Others


### Par opération

Je refais la régression pour les opérations principales du riz en Kharif. 

```{r}
reg_land <- Cultivation_all |>
  filter(OPERATION == "LAND PREPARATION") |>
  lm(formula = HACRE_OPER ~ CASTE_GROUP + AREA_CROP + AREA_CROP_SQ + AREA_HH + AREA_HH_SQ + IRRIGATION + MACHINERY + mechanized_tilling  + STATE,
     data = _)
summary(reg_land)
```

Attention : Pour cette régression, c'est normal que mechanized_tilling soit NA, car machinery_tilling et MACHINERY sont identiques. R ne considère pas le deuxième coefficient, à cause du problème de colinéarité que cela causerait. 


```{r}
reg_harvest <- Cultivation_all |>
  filter(OPERATION == "HARVESTING & THRESHING") |>
  lm(formula = HACRE_OPER ~ CASTE_GROUP + AREA_CROP + AREA_CROP_SQ + AREA_HH + AREA_HH_SQ + IRRIGATION + MACHINERY + mechanized_tilling  + STATE,
     data = _)
summary(reg_harvest)
```


```{r}
reg_weeding <- Cultivation_all |>
  filter(OPERATION == "HAND WEEDING") |>
  lm(formula = HACRE_OPER ~ CASTE_GROUP + AREA_CROP + AREA_CROP_SQ + AREA_HH + AREA_HH_SQ + IRRIGATION + mechanized_tilling + STATE,
     data = _)
summary(reg_weeding)
```

Attention: Il faut enlever Machinery pour étudier Hand weeding, car cette opération n'est jamais mécanisé. Il n'y a qu'une seule modalité pour Machinery, donc R ne peut pas créer de dummies. 


```{r}
reg_trans <- Cultivation_all |>
  filter(OPERATION == "TRANSPLANTING") |>
  lm(formula = HACRE_OPER ~ CASTE_GROUP + AREA_CROP + AREA_CROP_SQ + AREA_HH + AREA_HH_SQ + IRRIGATION + MACHINERY + mechanized_tilling + STATE,
     data = _)
summary(reg_trans)

```


### Avec le min de variables explicatives

```{r}
reg_min <- lm(HACRE_OPER ~ CASTE_GROUP + AREA_CROP + AREA_CROP_SQ + AREA_HH + AREA_HH_SQ + STATE, data = Cultivation_all)
summary(reg_min)
```

Variables nécessaires pour n'avoir aucune différence significative entre BC et FC: STATE + AREA_CROP ou AREA_HH


********************************************************************************

## Par type de travail

On refait les régressions précédentes, avec comme outcome les heures de travail par acre pour chaque type de travail (femme/homme, familial/employé).


### Créer la base par type de travail

Je calcule les heures de travail par champ, en différenciant par le type de travail

```{r}
Cultivation_labor <- Cultivation_paddy |>
  filter(!LAB_TYPE %in% c("RS", "HC", "FC")) |>

# 1. Somme des heures de travail par champ, caste et lab_type
  group_by(across(-WORK_HR)) |>
  summarise(WORK_HR = sum(WORK_HR, na.rm = TRUE), .groups = "drop") |>

# 2. Pivoter et créer les valeurs 0 quand le travail est nul
  pivot_wider(
    names_from = LAB_TYPE,
    values_from = WORK_HR,
    values_fill = 0
  ) |>

# 3. Calculer le travail total selon le genre
  mutate(
    WORK_F = HF + FF + EF,
    WORK_M = HM + FM + EM,
    WORK_O = OB + HB + EB + FB
  ) |>
  select(-'NA')
```

```{r}
# Diviser les heures de travail par acre
Cultivation_labor <- Cultivation_labor |>
  group_by(across(everything())) |>
  summarise(FF = FF/AREA_CROP,
            HF = HF/AREA_CROP,
            EF = EF/AREA_CROP,
            HM = HM/AREA_CROP,
            FM = FM/AREA_CROP,
            EM = EM/AREA_CROP,
            OB = OB/AREA_CROP,
            HB = HB/AREA_CROP,
            EB = EB/AREA_CROP,
            FB = FB/AREA_CROP,
            WORK_F = WORK_F/AREA_CROP,
            WORK_M = WORK_M/AREA_CROP,
            WORK_O = WORK_O/AREA_CROP,
            .groups = "drop")
```



### FF: Travail féminin familial

En se concentrant sur le ratio Hr/acre pour le travail féminin familial, on regarde s'il y a une différence significative entre FC et BC, avec les mêmes variables de contrôle. Notre hypothèse est que la demande de travail familial féminin soit moindre pour les FC. 

```{r}
reg_FF <- lm(FF ~ CASTE_GROUP + AREA_CROP + AREA_CROP_SQ + AREA_HH + AREA_HH_SQ + IRRIGATION + MACHINERY + mechanized_tilling  + STATE, data = Cultivation_labor)
summary(reg_FF)
```
#### Hand weeding

```{r}
reg_FF <- Cultivation_labor |>
  filter(OPERATION == "HAND WEEDING") |>
  lm(FF ~ CASTE_GROUP + AREA_CROP + AREA_CROP_SQ + AREA_HH + AREA_HH_SQ + IRRIGATION + mechanized_tilling  + STATE, data = _)
summary(reg_FF)
```

#### Harvesting

```{r}
reg_FF <- Cultivation_labor |>
  filter(OPERATION == "HARVESTING & THRESHING") |>
  lm(FF ~ CASTE_GROUP + AREA_CROP + AREA_CROP_SQ + AREA_HH + AREA_HH_SQ + IRRIGATION + MACHINERY + mechanized_tilling  + STATE, data = _)
summary(reg_FF)
```

#### Transplanting

```{r}
reg_FF <- Cultivation_labor |>
  filter(OPERATION == "TRANSPLANTING") |>
  lm(FF ~ CASTE_GROUP + AREA_CROP + AREA_CROP_SQ + AREA_HH + AREA_HH_SQ + IRRIGATION + MACHINERY + mechanized_tilling  + STATE, data = _)
summary(reg_FF)
```


### HF: Travail féminin employé

```{r}
reg_HF <- lm(HF ~ CASTE_GROUP + AREA_CROP + AREA_CROP_SQ + AREA_HH + AREA_HH_SQ + IRRIGATION + MACHINERY + mechanized_tilling  + STATE, data = Cultivation_labor)
summary(reg_HF)
```

### FM: Travail masculin familial

```{r}
reg_FM <- lm(FM ~ CASTE_GROUP + AREA_CROP + AREA_CROP_SQ + AREA_HH + AREA_HH_SQ + IRRIGATION + MACHINERY + mechanized_tilling  + STATE, data = Cultivation_labor)
summary(reg_FM)
```

### HM: Travail masculin employé

```{r}
reg_HM <- lm(HM ~ CASTE_GROUP + AREA_CROP + AREA_CROP_SQ + AREA_HH + AREA_HH_SQ + IRRIGATION + MACHINERY + mechanized_tilling  + STATE, data = Cultivation_labor)
summary(reg_HM)
```






